

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/vicety/Images@master/images/momiji-ico.ico">
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/vicety/Images@master/images/momiji-ico.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="vicety">
  <meta name="keywords" content="">
  
    <meta name="description" content="尽量简短的题目讲解 top100&#x3D;1 2 3 4 5 10 11 15 17 19 2021 22 23 25 31 32 33 34 35 3941 42 45 46 48 49 51 53 54 55 5662 64 70 72 73 74 75 76 78 7984 94 98 101 102 104 105 114121 124 128 … 按套路滑动窗口最大值：双端队列，左侧p">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode题目简短总结">
<meta property="og:url" content="https://vicety.github.io/2018/12/12/LeetCode%E9%A2%98%E7%9B%AE%E7%AE%80%E7%9F%AD%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="vicety的博客">
<meta property="og:description" content="尽量简短的题目讲解 top100&#x3D;1 2 3 4 5 10 11 15 17 19 2021 22 23 25 31 32 33 34 35 3941 42 45 46 48 49 51 53 54 55 5662 64 70 72 73 74 75 76 78 7984 94 98 101 102 104 105 114121 124 128 … 按套路滑动窗口最大值：双端队列，左侧p">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-12-12T21:16:01.000Z">
<meta property="article:modified_time" content="2023-03-12T19:42:00.160Z">
<meta property="article:author" content="vicety">
<meta property="article:tag" content="数据结构与算法">
<meta property="article:tag" content="加密">
<meta property="article:tag" content="总结">
<meta property="article:tag" content="刷题">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>LeetCode题目简短总结 - vicety的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"vicety.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"TdxzU2OpwN7XHsa0T05Y01Kn-gzGzoHsz","app_key":"lfgF4JmupaIQkD5xRHAIBfTk","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 90vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>vicety的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://cdn.jsdelivr.net/gh/vicety/Images@master/images/coding.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="LeetCode题目简短总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2018-12-12 22:16" pubdate>
          2018年12月12日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          24k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          197 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">LeetCode题目简短总结</h1>
            
            
              <div class="markdown-body">
                
                <p>尽量简短的题目讲解</p>
<p>top100&#x3D;<br>1 2 3 4 5 10 11 15 17 19 20<br>21 22 23 25 31 32 33 34 35 39<br>41 42 45 46 48 49 51 53 54 55 56<br>62 64 70 72 73 74 75 76 78 79<br>84 94 98 101 102 104 105 114<br>121 124 128 …</p>
<h2 id="按套路"><a href="#按套路" class="headerlink" title="按套路"></a>按套路</h2><p>滑动窗口最大值：双端队列，左侧pop对应元素移出，否则维护单调栈<br>滑动窗口中位数：与数据流中位数类似，但对有序结构的删除python无法用红黑树实现</p>
<p>最长上升子序列：对每个元素，尝试对当前维护的序列做优化或 append</p>
<h2 id="按序号"><a href="#按序号" class="headerlink" title="按序号"></a>按序号</h2><ol>
<li>2sum，hashmap</li>
<li>大整数求和，链表</li>
<li>最长无重复字母子串，维护 deque 窗口，用一个 set 使得能够 O1 获得窗口中字符串存在性</li>
<li>两个已排序数组的中位数，问题转化为两个已排序数组求第 k 大，不妨根据数组中位数位置大小定义数组为less, more，如果要取的k（从1开始）大于等于len lessHalf1Inclusive（左半含mid） + len moreHalf1Inclusive，那么一定可以排除lessHalf1Inclusive，至少能排除一个元素（保证算法结束），同时，取half时的mid按照向下取整取到，那么在k小于len lessHalf1Inclusive + len moreHalf1Inclusive时，也可以排除moreHalf2Inclusive，且至少能排除一个元素</li>
<li>最长回文子串，分 aba，aa 两种情况 dp 即可，O(n^2)全扫会TLE，应该从中心向两侧扩展，尽管最坏也是O^2，但平均情况（串随机生成）好很多</li>
<li>把字符串转化为 ZigZag 格式：downvote 多，TODO</li>
<li>翻转 32bit 整数，不断将右侧数字 i 取出，num &#x3D; num * 10 + i 即可，注意考虑溢出情况，尝试&#x2F;10 能否复原数字即可，详见这里</li>
<li>编写函数将字符串转化为数字，On 扫描题，有数字就不能有符号，有符号则只能有一个，出现其余符号或数字已经超出则立即返回</li>
<li>判定数字是否是回文的，不可转为字符后处理。不断将原有数字popright &#x3D; i 取出，添加到新数左侧，即num &#x3D; num * 10 + i，while新数小于旧数，最后比较是否<code>oldNum = newNum or oldNum / 10 = newNum</code><br>代码见<a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-number/discuss/5127/9-line-accepted-Java-code-without-the-need-of-handling-overflow">这里</a></li>
<li>带.*的字符串匹配，二维 dp，画一下方格转移就好</li>
<li>柱状图最多能装多少水（两根柱子中间的柱子不考虑体积），每次移动较矮的柱才有获得更优解的可能性，双指针<br>assume height[i] &gt; height[j]<br>a. solve(i, j) &#x3D; compute(i, j) + compute(i, [j-1, ]) + solve(i+1, j)<br>或者<br>b. solve(i, j) &#x3D; compute(i, j) + compute([i+1, ], j) + solve(i, j+1)<br>注意到 compute(i, j) &gt; Any(compute([i+1, ], j))，这部分计算可以忽略，因此b等价于compute(i, j) + solve(i, j+1) 即计算完当前位置后，只需要移动较短的那个即可，而a中仍需要O(n)计算所有(i, [j-1,])的状态，效率上不如b方案</li>
<li>整数转罗马数字，TODO</li>
<li>罗马数字转整数，TODO</li>
<li>多个字符串的最长公共前缀，随便拿一个字符串去检查其他字符串即可</li>
<li>3Sum，要求打印所有解，排序，双指针完成 2Sun，外层再套一个 for，On^2</li>
<li>3Sum Closest，求最接近的值，同上一题解法</li>
<li>电话按键能够组成多少字母排列，简单 dfs</li>
<li>4Sum，同 3Sum</li>
<li>移除链表尾部开始的第 N 个节点，dummy 节点+前后指针</li>
<li>验证括号合法性，注意([)]是非法的，栈模拟即可</li>
<li>两链表合并，简单</li>
<li>生成由 n 对括号组成的所有合法括号串，dfs</li>
<li>合并 k 个链表，最小堆或两两合并</li>
<li>链表中每两个节点交换一次，根据后续节点情况（后续还有至少两个节点，后续不足两个节点）进行链表重连即可</li>
<li>链表中每 k 个节点倒序一次，dummy+判断 hasNextK+翻转 k 个+前后段连接，代码见<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/280039821/">这里</a></li>
<li>inplace 移除数组中的重复元素，非重复元素靠左放置，返回去重后的个数，简单</li>
<li>inplace 移除数组中的特定元素，简单</li>
<li>字符串匹配，考察 kmp 默写，注意字符串为空的边界条件</li>
<li>计算除法，TODO</li>
<li><strong>需要复习12</strong>给出字符串 s、长度一样的字符串数组 t，求 s 中存在的由 t 中所有字符串任意顺序拼接组成的字符串的所有起点位置，复杂度 O(mn)，m 为 t 中字符串长度. n 为字符串 s 长度，字符串 s 根据起始 index 不同分为 m 次循环来找，每次查找都是一个维护滑动窗口的过程，代码与详细讲解见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/grandyang/p/4521224.html">这里</a><br>推荐（我的写法）：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/submissions/887634539/">https://leetcode.com/problems/substring-with-concatenation-of-all-words/submissions/887634539/</a></li>
<li>求组合的 Next Permutation，要求 inplace 操作，O1 空间<br>从右往左找第一个升序位置（如12就是一个升序，或者比如 35421 的 3），因为降序已经是最大字典序了，只有找到升序，我们才能找到比当前更大的字典序。<br>在字典序的视角中，降序部分是最大值（类似于2999这样的数，下一个数是3000），类似的，我们将找到的升序位置的数与右侧降序序列中中比它大的最小值交换，如45321交换后未54321，右侧一定仍然是降序序列，我们需要通过类似字符串翻转的方式将其变为升序序列，即51234</li>
<li>Longest valid parenthesis：<strong>需要复习1</strong>（我觉得难点在初见怎么想到dp以外的做法是错的，重点在于连接先前的闭合括号） On 复杂度，dp[i]存储以位置 i 结尾，匹配到的 <code>(())</code> 格式，而非 <code>()(())</code> 格式括号字符串的长度，每次遇到右括号，要么看前一个位置：<br>如果是左括号，那么还要继续尝试和更前的位置连接<br>如果不是左括号但 dp 不为 0，那么沿着 dp 到更前的位置看那个位置是否是左括号<br>举个例子 <code>(())()</code>，右侧的 <code>()</code> 匹配完成后需要 check dp[3]的位置</li>
<li>在旋转后的有序数组中搜索，二分，判断情况，不确定的时候可以加固代码</li>
<li>有序数组找 lower_bound upper_bound，二分</li>
<li>有序数组找新数字的 insert position，二分</li>
<li>验证数独中已有数字的合法性，简单模拟</li>
<li>求解数独，dfs</li>
<li>Count ans say，模拟</li>
<li>Combination Sum，完全背包求所有解，dfs</li>
<li>多重背包求所有解，dfs</li>
<li>First Missing Positive，数字放到其对应下标即可</li>
<li>求坑洼地形能装多少水，（难点在怎么想到单调栈）单调栈<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/350910072/">https://leetcode.com/submissions/detail/350910072/</a> 维护一个单减栈，每当违反单调性时出栈，当前元素 a，出栈元素 b，出栈后栈顶元素 c，判断判断 abc 关系来 update ans，每次 update 相当于填平一个坑，注意需要同时存下标与高度，下标指同一高度的最左位置；双指针<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/323086054/">https://leetcode.com/submissions/detail/323086054/</a> 维护左右较小高度作为“桶”的短板，较矮的一方向中间移动，根据新的高度修改 ans 或 update 短板高度</li>
<li>模拟竖式乘法，没必要基于竖式加法做，两位相乘直接用一个int存起来，最后统一做进位</li>
<li>？代替单个字符，*代替任意长度（包括 0）串，问 string 与 pattern 是否 match，可以 O(N^2) dp，也有 On 的做法，维护 str、pattern 指针、上一个 star 的位置、上一个 star 匹配到的位置，star 初次遇见仅更新上一个 star 位置，不做任何匹配，后续发生失配时回到上一个 star 处尝试用这个 star 继续匹配，代码见下（我还没有完全理解原理）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(String s, String p)</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">sLen</span> <span class="hljs-operator">=</span> s.length(), pLen = p.length();<br>  <span class="hljs-type">int</span> <span class="hljs-variable">sIdx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, pIdx = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">starIdx</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, sTmpIdx = -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">while</span> (sIdx &lt; sLen) &#123;<br>    <span class="hljs-comment">// If the pattern caracter = string character</span><br>    <span class="hljs-comment">// or pattern character = &#x27;?&#x27;</span><br>    <span class="hljs-keyword">if</span> (pIdx &lt; pLen &amp;&amp; (p.charAt(pIdx) == <span class="hljs-string">&#x27;?&#x27;</span> || p.charAt(pIdx) == s.charAt(sIdx)))&#123;<br>      ++sIdx;<br>      ++pIdx;<br>    &#125;<br>    <span class="hljs-comment">// If pattern character = &#x27;*&#x27;</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pIdx &lt; pLen &amp;&amp; p.charAt(pIdx) == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>      <span class="hljs-comment">// Check the situation</span><br>      <span class="hljs-comment">// when &#x27;*&#x27; matches no characters</span><br>      starIdx = pIdx;<br>      sTmpIdx = sIdx;<br>      ++pIdx;<br>    &#125;<br>    <span class="hljs-comment">// If pattern character != string character</span><br>    <span class="hljs-comment">// or pattern is used up</span><br>    <span class="hljs-comment">// and there was no &#x27;*&#x27; character in pattern</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (starIdx == -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// If pattern character != string character</span><br>    <span class="hljs-comment">// or pattern is used up</span><br>    <span class="hljs-comment">// and there was &#x27;*&#x27; character in pattern before</span><br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Backtrack: check the situation</span><br>      <span class="hljs-comment">// when &#x27;*&#x27; matches one more character</span><br>      pIdx = starIdx+<span class="hljs-number">1</span>;<br>      sIdx = sTmpIdx + <span class="hljs-number">1</span>;<br>      sTmpIdx = sIdx;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// The remaining characters in the pattern should all be &#x27;*&#x27; characters</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> pIdx; i &lt; pLen; i++)<br>    <span class="hljs-keyword">if</span> (p.charAt(i) != <span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="45">
<li>Jump Game，问最少需要几跳到达，维护当前最远位置、当前已访问位置、当前跳数，每次批量访问这一跳能够到达的所有位置，同时更新最远位置</li>
<li>不重复数字数组，求全排列，dfs，用一个 set 记录 vis</li>
<li>可重复数字数组，求不重复的所有排列，添加数字可选 1-n 个，强制要求下一次添加数字与上一次添加的不能一样</li>
<li>Rotate image，计算四个位置的相互 mapping 即可</li>
<li>给定一个字符串数组，将其按 set([c for c in str])的结果分类，排序即可</li>
<li>快速幂，不需要打表</li>
<li>N 皇后解的个数，重点在于找到斜向皇后的表示方法，标记在数组中表示已占据</li>
<li>N 皇后求所有解，同上</li>
<li>最大的子数组和，扫一遍，每个数字 update 一次，维护当前 sum，如果已经小于 0，那么重置为 0</li>
<li>打印螺旋矩阵，一个 while 套四个 while，大概</li>
<li>Jump Game，同 45 题</li>
<li>区间合并，区间打散为开始事件与结束事件，事件按时间排序，开始入栈，结束出栈</li>
<li>区间插入，同上</li>
<li>最后一个单词的长度，如”Hello World”返回 World 长度，简单</li>
<li>生成螺旋矩阵，同 54 题</li>
<li>生成由数字 1-n 组成的全排列中的第 k 项，对于第 i 位数字是 j，第 1 到 i-1 位数字的全排列共(i-1)!种，第 i 位小于 j 时的全排列共(j-1)*(i-1)!种，通. 过这一方法判断当前位应该取第几个还没用过的从小到大的数字</li>
<li>将链表右侧 k 个元素放到链表开头，前后指针</li>
<li>机器人只能往右或者往下，求走法总数，dp</li>
<li>62 题存在路障，dp</li>
<li>61 题每走到一个需要消耗费用，求最小消耗费用，dp</li>
<li>数字格式校验，TODO，存在“ -90.1e3”这种</li>
<li>用数组表示的数字（每个位置表示一个字符），对其加一，简单</li>
<li>用字符串实现二进制加法，简单</li>
<li>给出一些字符串和每行最大长度，最后一行左对齐间距一个空格，其余行左右对齐，间距均分，无法均分的情况下左侧间距大于右侧间距。每次尝试. 对容器加入字符串，如果长度溢出，做一次左右对齐的结算，这样确保了访问完全部字符串时容器内不为空，此时一定能再做一次左对齐结算</li>
<li>求 floor(sqrt(x))，如input&#x3D;8 output&#x3D;2，不允许使用pow(x, n)</li>
<li>上楼梯步数问题</li>
<li>Linux路径最简化，如&#x2F;home&#x2F;..&#x2F;foo&#x2F;简化为&#x2F;foo</li>
<li>编辑距离<br>很久以前面试初见挂过一次，实际上不难</li>
</ol>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + (<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> word1[i - <span class="hljs-number">1</span>] != word2[j - <span class="hljs-number">1</span>] <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>), <span class="hljs-comment"># replace</span><br>                              dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, <span class="hljs-comment"># delete word1</span><br>                              dp[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, <span class="hljs-comment"># add word1</span><br>                              ) <br></code></pre></td></tr></table></figure>

<ol start="73">
<li>O1 空间操作矩阵，使得值为 0 的位置所在行、列全为 0。使用第一行第一列记录所在行列是否存在 0，同时需要记录第一行第一列本身是否存在 0</li>
<li>二维递增数组搜索，剑指第几题来着。二分找起始搜索列，然后一列列往左搜，其实在搜列的时候也可以限制上方搜索起始位置的<ol>
<li>也可以这样：从右上角开始搜，对任何一个位置，如果target比它大，向下搜，如果比它小，向左搜，O(n)，其实坐标ij可以看成是双指针问题</li>
<li>2022-02 update：感觉之前都看错题目了，本身自己就是一个递增的数组，只是给写成了二维的格式，那不就一个index映射到二维完事吗？</li>
</ol>
</li>
<li>O(n) time O(1) space 对仅含 012 的数组排序，双指针走类似快排 partition 的流程，需要注意换回来的数字不一定是自己阵营的<ol>
<li>2022-02 update：就是三明治快排的一个iteration</li>
</ol>
</li>
<li>S&#x3D;”ADOBECODEBANC”, T &#x3D; “ABC”，找到 S 中包含 T 中所有字符的最短串，维护滑动窗口 Deque、需求字符的 HashMap、已有字符的 HashMap，每当达. 标时更新答案，pop 直到不达标</li>
<li>求 C(n, k)的所有下标组合，dfs</li>
<li>求所有子集，dfs</li>
<li>在字符矩阵中搜字符串，dfs</li>
<li>distinct 数组，使得数组中每种数字最多出现两次，inplace 操作</li>
</ol>
<p>… 暂定写到100</p>
<ol start="96">
<li><strong>需要复习12F3F</strong> 1-n组成结构不同BST的数量 太狠了，居然是DP</li>
<li>将字符串a和b中的字符，保留其在自身中的顺序进行合并，问是否能得到字符串c<br>容易想到搜索，但dp是更好的</li>
<li><strong>需要复习1</strong> 展开二叉树为链表<br>很好的递归题<br>两种解法<br>一种是展开左侧，展开右侧，分别获得其 head tail，然后与 root 拼接，注意判断左侧、右侧不存在的情况</li>
</ol>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>flattenLHead, flattenLTail = solve(root.left)<br>flattenRHead, flattenRTail = solve(root.right)<br><span class="hljs-keyword">if</span> flattenLTail <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    root.right = flattenLHead<br>    flattenLTail.right = flattenRHead<br>    <span class="hljs-keyword">if</span> flattenRTail:<br>        <span class="hljs-keyword">return</span> root, flattenRTail<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> root, flattenLTail<br><span class="hljs-keyword">else</span>:<br>    root.right = flattenRHead<br>    <span class="hljs-keyword">if</span> flattenRTail:<br>        <span class="hljs-keyword">return</span> root, flattenRTail<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> root, root<br></code></pre></td></tr></table></figure>

<p>另一种是直接找到左节点的最右节点，它就是 root.left flatten 后的 tail，将左侧拼接到右侧后，递归 solve root.right</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    now = root.left<br>    <span class="hljs-keyword">while</span> now.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        now = now.right<br>    now.right = root.right<br>    root.right = root.left<br>    root.left = <span class="hljs-literal">None</span><br>solve(root.right)<br></code></pre></td></tr></table></figure>

<p>20230129 update，也可以看我最新的解法，虽然复杂一点，但是是自己的思路<br><a target="_blank" rel="noopener" href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/submissions/887653292/">https://leetcode.com/problems/flatten-binary-tree-to-linked-list/submissions/887653292/</a></p>
<ol start="121">
<li>买卖股票系列 专门有写一篇文章</li>
<li>买卖股票系列 专门有写一篇文章</li>
<li>买卖股票系列 专门有写一篇文章</li>
<li>随机数组中的最长连续序列长度，直觉是并查集，实际上不需要<br>TODO 并查集和set的区别是？</li>
<li>复制带随机指针的数组，维护original到cp节点的映射，第二轮复制random<br>TODO O1 思路是利用现有字段（也许是在第一遍利用random字段？）</li>
<li>链表判环</li>
<li><strong>需要复习1</strong>求环所在的位置：快慢指针判环，如果有环，分别从第一次相遇位置、起点再次开始以相同速度行走，下次相遇的位置即环的入口<br>解释：第一次慢的走了x，快的2x，快的套了慢的n圈，圈长度为c，有x&#x3D;nc。按照上面的策略重新出发，在环内出发的A，和起点出发的B，假设再走x，还是会停在当前位置，即最终一定会走一段重合路径：从环入口到第一次相遇位置。走的同时比较当前节点是否相等，取首个重合位置，即环的入口<br>20230129 update：也可以这样看，从起点到相遇位置（慢指针）和相遇位置走n圈再到相遇位置（快指针多出来的部分）是一样长的，那么重新以相同速度出发，一定能在环入口相遇</li>
<li>链表排序，快慢指针找到中点，长度为1单判，为2可以从dumb node开始快慢指针。归并</li>
<li>值域 -10,10 的数组找乘积最大子串</li>
</ol>
<ul>
<li>先不考虑0</li>
<li>collect更多数字在绝对值上永远不会下降</li>
<li>实际上只是看取多少负号</li>
<li>奇数负号必定取两个，偶数必定全取</li>
<li>那么其实只有奇数负号有选择上的问题，并且无非是左侧负号不取还是右侧负号不取的问题</li>
<li>如果考虑0，遇到0等于从右侧重新开始求解<br><a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/643655810/">https://leetcode.com/submissions/detail/643655810/</a></li>
</ul>
<ol start="155">
<li><strong>需要复习12</strong>支持常数时间获得最小值的栈</li>
</ol>
<ul>
<li>使用额外空间维护一个单调递减栈</li>
</ul>
<ol start="168">
<li><strong>需要复习12F</strong> Excel表格的A转化为1，AA转化为27，实现这个映射，建议找规律，一步步实现，这题其实很难</li>
<li>买卖股票系列 专门有写一篇文章</li>
<li>TODO</li>
<li><strong>需要复习</strong>ref 862 862中数字不一定是正的。求最短子数组，使得和大于等于target</li>
</ol>
<ul>
<li>解法1：尺取 On<br>维护左侧前缀，popleft并更新答案直到窗口和小于target<br><a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/668622896/">https://leetcode.com/submissions/detail/668622896/</a><br>如果不是正的就没法用窗口扩展收缩来做了，因为没法确保收缩过程一定使得窗口和递减<br>考虑如下 testcase<br>nums&#x3D;[84,-37,32,40,95]<br>target&#x3D;167</li>
<li>解法2：二分 Onlogn<br>维护前缀和，有递增的特性，对于当前的前缀和，二分找到第一个这样的位置，使得 <code>prefix[now] - prefix[i] &gt;= target</code></li>
<li>follow up：如果数组不一定是正数（丧失前缀和递增的特性），那么用和之前的二分思路类似，但是需要用红黑树维护已经访问过的前缀和，并 logN 找到第一个符合条件的位置</li>
</ul>
<ol start="215">
<li><strong>经典</strong> 第K大，目的是复习快排</li>
<li>也是剑指43，1-9 1-99 …的可以简单求得，然后将问题分割，从高位到低位求解，每位分为数字等于1，大于1的情况<br>代码 <a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/649921961/">https://leetcode.com/submissions/detail/649921961/</a><br>（顺带吐槽一下，国内太卷了，LC 98%，国内20%，当然可能和波动有关）</li>
<li>回文链表，O1空间，快慢指针获得长度（注意区奇偶），然后翻转后半部分。在最后遍历的时候甚至可以将后半部分再翻转回来</li>
<li><strong>需要复习</strong>Product of Array Except Self，返回一个数组，不允许用除法，要求 On<br>从左到右乘一遍，再从右到左乘一遍</li>
<li>矩阵，横向递增，纵向递增，找 target<br>从右上角开始搜，令人惊讶的是 On 居然能过<br>二分法需要注意，横向是找到第一个小于的位置，纵向则是找到第一个大于的位置<br>二分参考：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-a-2d-matrix-ii/submissions/903148093/">https://leetcode.com/problems/search-a-2d-matrix-ii/submissions/903148093/</a></li>
<li><strong>需要复习1</strong>给出数字n，问最少用几个平方数的和可以得到n<br>从值域不大应当想到是DP<br>但是这道题的时间卡得有点离谱</li>
<li>在由 0-9 组成的字符串间添加 加减乘 三种符号，使得运算结果为 target<br>数字长度小于 10，意味着可以 <code>回溯</code> 来做，最多 9 个符号，<code>3 ^ 9 = 27 * 27 * 27</code>，也就是几千的搜索范围，每次 eval On，大概是 几万 级别的运算量<br>优化，这个老哥的做法模仿了 eval 表达式的做法，如果是乘法，则需要先抵消上次的结果（需要在递归间维护，可能是 加减乘），然后对上次的结果乘算</li>
<li><strong>需要复习</strong>数组中只有一个数重复两次，值域等于一到数组长度，不修改数组，常数空间找到它。等价于找到链表环入口<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/solution/287xun-zhao-zhong-fu-shu-by-kirsche/">https://leetcode-cn.com/problems/find-the-duplicate-number/solution/287xun-zhao-zhong-fu-shu-by-kirsche/</a></li>
<li><strong>需要复习</strong>数据流中位数</li>
</ol>
<ul>
<li><p>解法1：注意新数字加到高半部集合还是低半部集合的判断，在高半部的数据应当放到高半部集合，反之亦然，之后执行平衡操作<br><a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/688005887/">https://leetcode.com/submissions/detail/688005887/</a><br>Question：如果总是添加到低半部的问题是什么？<br>如果低半部大小为3，高半部大小为5，那么添加大数到低半部后不会触发平衡操作，这也是解法2做的改进</p>
</li>
<li><p>解法2：总是添加到低半部，随后确保平衡，在平衡的基础上check并确保小半部最大值总是小于等于大半部最小值<br><a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/804194976/">https://leetcode.com/submissions/detail/804194976/</a></p>
</li>
</ul>
<ol start="300">
<li><strong>需要复习1</strong>最长递增子序列，在维护的序列中，找到第一个大于等于当前数字的数（先确保存在），改良它</li>
<li><strong>需要复习</strong>牛逼的dfs，建议多做<br>TODO 301 还没通过</li>
<li><strong>需要复习</strong>硬币组合得到target值，无限背包，经典dp，需要注意循环的安排</li>
<li><strong>需要复习</strong>二叉树robber，相邻节点不能同时rob 学习一下自己的提交和这个的区别，自己的提交将prev状态维护在参数中，导致再次进入这一状态时需要从全局的缓存map中读之前的计算结果，而下方这个方法不考虑prev，而是考虑next，通过递归的返回值获得下一个节点两种状态分别的结果，然后在当前节点计算，不需要备忘录，妙</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>        <span class="hljs-type">int</span>[] result=robHelp(root);<span class="hljs-comment">//result:&#123;&quot;no-root answer&quot;,&quot;root answer&quot;&#125;</span><br>        <span class="hljs-keyword">return</span> Math.max(result[<span class="hljs-number">0</span>],result[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] robHelp(TreeNode node)&#123;<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<span class="hljs-comment">//base case</span><br>        <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//node!=null</span><br>            <span class="hljs-type">int</span>[] left=robHelp(node.left);<br>            <span class="hljs-type">int</span>[] right=robHelp(node.right);<br>            <span class="hljs-type">int</span>[] result=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>            result[<span class="hljs-number">0</span>]=Math.max(left[<span class="hljs-number">0</span>],left[<span class="hljs-number">1</span>])+Math.max(right[<span class="hljs-number">0</span>],right[<span class="hljs-number">1</span>]);<span class="hljs-comment">//no-root answer</span><br>            result[<span class="hljs-number">1</span>]=node.val+left[<span class="hljs-number">0</span>]+right[<span class="hljs-number">0</span>];<span class="hljs-comment">//root answer</span><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="358">
<li><p>对一堆字符排序，使得排序后相同字母间距至少为 k<br>（lintcode 907 已验证下面思路可以 AC）<br>我的想法：对每个字符维护余量，维护 deque、set，也就是滑动窗口，新字符从不在滑动窗口中的、剩余最多的字符中选，如果选不到说明没法实现</p>
</li>
<li><p><strong>需要复习</strong>两个有序数组ab，从ab各取一个数字求和，有N^2中组合，求组合前K大<br>等价于二维地图，从 (0, 0) 开始 BFS<br>从0,0开始，放入堆，每次从堆中取出，记录答案，添加这个位置的后两个位置（即二维图中的下方和右方位置）到堆，记得去重</p>
</li>
<li><p><strong>需要复习</strong>蓄水池抽样，O1 空间，1&#x2F;n 保留新的元素，(n-1)&#x2F;n 保留原有元素<br>follow up: 若保留 K 个元素如何做？<br>对于当前状态，肯定也是使得 k&#x2F;n 概率新的元素被加入采样，问题在于如何使得对于新来的元素（使 met 元素数量 N -&gt; N+1），使得被采样的元素的概率变为 k&#x2F;N -&gt; k&#x2F;(N+1)</p>
</li>
<li><p><strong>需要复习</strong>分割数组，使得分割后的两份之和相同。数字值很小，可以背包，需要注意只能用一次时的dp方向。（<strong>如果是面试需要确认值域范围，之后才确认可以背包</strong>）</p>
</li>
<li><p><strong>需要复习</strong>求树上仅往下的路径中，和为target的路径数量。维护访问路径前缀和字典（<strong>因为是点查询而不是范围查询，如求最大最小值，因此可以用哈希表实现 O1</strong>）</p>
</li>
</ol>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">res</span>(<span class="hljs-params">self,root,d,sum1,count,target</span>):<br>    <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span><br><br>    sum1+=root.val<br>    <span class="hljs-keyword">if</span> sum1-target <span class="hljs-keyword">in</span> d:<br>        count[<span class="hljs-number">0</span>]+=d[sum1-target]<br>        <br>    <br>    <span class="hljs-keyword">if</span> sum1 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> d:<br>        d[sum1] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        d[sum1]+=<span class="hljs-number">1</span><br>    <br>    self.res(root.left,d,sum1,count,target)<br>    self.res(root.right,d,sum1,count,target)<br>    d[sum1]-=<span class="hljs-number">1</span><br>    <br>    <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pathSum</span>(<span class="hljs-params">self, root: <span class="hljs-type">Optional</span>[TreeNode], targetSum: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    d = &#123;<span class="hljs-number">0</span>: <span class="hljs-number">1</span>&#125;<br>    count = [<span class="hljs-number">0</span>]<br>    self.res(root,d,<span class="hljs-number">0</span>,count,targetSum)<br>    <br>    <span class="hljs-keyword">return</span> count[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>

<ol start="450">
<li><strong>需要复习12F</strong>BST节点删除，<strong>不要以为自己会了</strong></li>
<li><strong>需要复习</strong>给定str1 str2，问str2最大重复次数，使得str1通过删除字符能够得到str2。其中str1 str2都是基于某个（str1和str2的不同）字串重复自身得到的，如str1&#x3D;”abcabcabc” str2&#x3D;”abab”</li>
<li><strong>需要复习</strong>strA是无限循环的a-z串，求strB有多少子串是strA的子串</li>
<li>给出房子的位置和取暖器的位置，求最小的取暖器供暖范围<br>1. 将取暖器和房子排序，将取暖器组成链表，遍历房子，根据其距离前后取暖器的位置更新答案<br>2. 将取暖器和房子排序，二分找第一个小于等于和第一个大于等于，更新答案</li>
<li><strong>需要复习</strong>滑动窗口中位数</li>
</ol>
<p>解法1：维护链表，复杂度 Onk<br>解法2：大致的解法类似于数据流中位数，但是为了维护滑动窗口，需要在 logN 删除 最大&#x2F;最小堆中某个元素，这是只有红黑树才能支持的，Python 没有，面试就直接说 Python 搞不定<br>488. 祖玛，给出当前状态、手中球集合，问最少用几个球全消。问题在于没有明确想法的情况下敢不敢写相对暴力的解法<br>486. <strong>需要复习1</strong>看出DP+写对，其他人的答案更狠……<br>两名玩家可以从双端队列两侧拿数字累加到自己的分数上，两名玩家都采取最优策略，玩家1先行动，求结果<br>正数代表玩家1<br>根据当前长度判断是谁的回合<br>solve(0, sz-1)&#x3D;max(solve(1, sz-1)+num[0], solve(0, sz-2)+num[sz-1])<br>solve(x, y)&#x3D;max(solve(x+1, y)-num[0], solve(x, y-1)-num[y])<br>solve的初始值默认初始化为0即可<br>491. 求数组的所有递增子序列<br>494. 数组中的每个数字都可以改变正负号，问使数组和为target有多少种组合。dfs或者dp，注意看下初始条件怎么写<br>498. zigzag斜向访问矩阵，维护好两侧开始位置的iterator就好，一侧是往右上，一侧是往左下，每次移动两个位置<br>560. <strong>需要复习1</strong> 求数组中和为K的subarray有多少个<br>一看就要预处理前缀和，问题转化为求所有的(i, j)组合，使得 <code>prefix[j]-prefix[i]=target</code>，转化为 2sum，遍历 prefix，在字典维护，同时找是否有满足 <code>prefix_now = target + prefix[prev]</code> 的情况<br>581. 找到最短的子数组，如果将子数组排序，整个数组有序。<br>先进入这样的状态，左侧最长递增，中间未知，右侧最长递增。然后找到中间的最小最大值，while左侧最靠近中间的位置大于最小值，向左扩张中间这段的边界，同时更新中间这段的最大值，右侧同理，最后返回中间这段的长度。<br>TODO 扩展边界的过程可以二分<br>717. 两种字符，第一种用0代表，第二种用10或11代表，问docode比特串后，最后一个字符是否是第一种字符<br>简单，decode方式是唯一的<br>726. 给出化学式，计算原子数量，如 K4(ON(SO3)2)2 有 K 4个 O 14个，等等<br>类似表达式求值，当前维护一个 dict，遇到终止字符时，与 ans dict merge，遇到数字时对当前 dict 内元素翻 N 倍即可<br>739. <strong>需要复习1</strong> 给定气温序列，对每天求多少天后出现第一个比当天气温更高的天<br>从右往左的做法：维护单调栈，左侧温度高的可以淘汰右侧温度小于等于的<br>（推荐）从左往右的做法：维护单调栈，新来的天将栈中所有温度低于它的天淘汰并计算答案<br>763. 分割字符串，使得每种字符仅在一个分割内出现<br>统计每个字符的最后一次出现，一步步扩张维护区间，当区间能够覆盖内部所有字符的最后一次出现位置时（实际上只用维护最大值），产生一个分割<br>863. 二叉树中距离某节点不重复路径长度为K的所有节点<br>解法1：建图<br>解法2：存访问路径，但要注意找到结果后，要么返回一个特殊值，让上层递归不要继续走了，要么计算结果时不要破坏访问栈 （<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/650507161/">https://leetcode.com/submissions/detail/650507161/</a> 26行）<br>1000. <strong>需要复习</strong> 合并石堆，每次合并K个，合并费用为区间和，并没看懂做法，先会做K&#x3D;2的情况吧，参考<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/6d3ccbc5b6ad4f12b8fe4c97eaf969e0">https://www.nowcoder.com/questionTerminal/6d3ccbc5b6ad4f12b8fe4c97eaf969e0</a><br>状态转移<code>dp[i][j] = Math.min(dp[i][j],dp[i][k] + dp[k + 1][j] + sum)</code><br>1171. 删除链表中所有连续段，这些段的和为0，直到不再存在这样的段<br>抄的一个优雅的做法，维护idx到前缀和的映射，相同的前缀和保留最后一个。然后再遍历一遍，对每个已经遇到过的前缀和，修改链表略过它们中间的那段<br><a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/796047203/">https://leetcode.com/submissions/detail/796047203/</a><br>1547. 给定绳子和一些互不相同的切割点，每次切割的代价是切割前长度，问使得代价最少的方案的这个最少代价是多少<br>最多 100 个切割点，直接 On3 dp<br>dfs + 记忆化 会更加直观，见 <a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-cost-to-cut-a-stick/discuss/780880/DP-with-picture-(Burst-Balloons">https://leetcode.com/problems/minimum-cost-to-cut-a-stick/discuss/780880/DP-with-picture-(Burst-Balloons</a>)<br>做的时候想到的另一个方案，初始状态是全部切割的状态，每次合并选择合并代价最小的进行，结果发现并不是最优的</p>
<h3 id="不按题号"><a href="#不按题号" class="headerlink" title="不按题号"></a>不按题号</h3><p>没详细写步骤的都是非常简单的，没必要复习</p>
<h5 id="252"><a href="#252" class="headerlink" title="252"></a>252</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/grandyang/p/5240774.html">https://www.cnblogs.com/grandyang/p/5240774.html</a></p>
<p>Meeting Room</p>
<p>看一堆数组是否重叠，按开始排序</p>
<h5 id="253"><a href="#253" class="headerlink" title="253"></a>253</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/grandyang/p/5244720.html">https://www.cnblogs.com/grandyang/p/5244720.html</a></p>
<p>Meeting Rooms II</p>
<p>找重叠次数最大值</p>
<p>按event打散排序来做，开始加入集合，结束移除</p>
<p>或者</p>
<h5 id="321"><a href="#321" class="headerlink" title="321"></a>321</h5><p>两个数组，从中共取N个数，每个数组中取出的是序列（不需要连续，但保持顺序）<br>遍历arr1去X个arr2取N-X个的情况，对于arr在数组中找到能取到的最大数</p>
<p>TODO 之前的策略没看懂，重新想了一个策略 <a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/315245122/">https://leetcode.com/submissions/detail/315245122/</a><br>策略是：从高位开始选数字，剩下的位置需要足够填充X个，然后就是找最大数字就行了</p>
<p>之后就是链表合并了</p>
<h5 id="324"><a href="#324" class="headerlink" title="324"></a>324</h5><p>Wiggle Sort 好像是叫这个名字</p>
<p>给出一定符合要求的数组，对其重排序，使得值从index0-1开始满足严格上升、下降、上升、下降…的规律</p>
<p>极限情况：11122 -&gt; 12121<br>naive：排序，偶数位（index&#x3D;13579）放最大一半的数字，奇数位放最小一半的数字，注意避免最大一半的最小和最小一半的最大在一起，因为有可能是相同数字<br>问题抽象：实际上就是找第K大</p>
<p>找到第K大后，申请一个数组，前半部分放奇数位置（更小的一半），后半部分放更大的一半，遍历数组，跳过数字等于mid的情况，其余情况分别放入前后一半，向后移动指针，最后指针小于边界的位置剩下的必定是mid，最后填充会原来数组的时候记得用相反方向遍历</p>
<p>空间O(1)对我还是有点难<br>TODO</p>
<p>一个需要注意的case是 [4, 5, 5, 6]，mid&#x3D;5。如果大于5的反向填充，小于的正向填充，就会产生[4,5,5,6]的情况，小于的反向填充则不会  </p>
<h5 id="402"><a href="#402" class="headerlink" title="402"></a>402</h5><p>数字中移除K个数，使得结果最小</p>
<p>每遇到AB，A&gt;B，移除A，如果已经是升序数组，那么移除最后一个数<br>注意前缀0的情况</p>
<h5 id="432"><a href="#432" class="headerlink" title="432"></a>432</h5><p>Inc、Dec 都是简单的字典操作，难点在于 O(1)排序，加减一简化了排序问题，使得可以通过链表操作 O(1)完成排序，缺陷是对于相同数字过多的情况下不是 O(1)，可以将所有具有相同 value 的元素放在同一个节点以解决此问题。</p>
<h5 id="438"><a href="#438" class="headerlink" title="438"></a>438</h5><p>题意：对字符串 s，找到所有下标 i，使得 Set<Character>(s.substring(i, i + k))等于 Set<Character>(targetStr)，其中 k 为 targetStr 的长度</p>
<p>解法：窗口大小固定，考虑维护一个哈希值使得能够 O(1)判断 Set 是否相等，最终考虑使用一个 int[26]存储字符出现次数</p>
<h5 id="440"><a href="#440" class="headerlink" title="440"></a>440</h5><p>题意：给出数字 n、k，求数字 1-n 按字典序排序后的第 k 个数字</p>
<p>解法：从高位到低位枚举数字（也可以说是枚举前缀），如果高位固定，低位填满不够到达 k，那么高位++，k-&#x3D;低位填满所需容量，如果低位填满的容量大于所剩 k，那么得到答案的高位，继续求答案的下一位。低位填满通过判断 prefix 10, 100, *1000 是否大于 n 获得，代码见参考</p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/discuss/92254">LeetCode discussion</a></p>
<h5 id="441"><a href="#441" class="headerlink" title="441"></a>441</h5><p>题意：n 枚硬币，摆成第 i 行有 i 个硬币的形状，问最后一个硬币数满足需求的行数</p>
<p>解法：加法可能溢出，用减法</p>
<h5 id="442"><a href="#442" class="headerlink" title="442"></a>442</h5><p>题意：找出数组中出现两次的所有数字，其余数字只出现一次，数字值域限制在[1, arr.length]，输出答案以外的空间限制在 O(1)</p>
<p>解法：一看限制值域就知道是利用下标存数字，令 0 代表 empty，-1 代表出现两次</p>
<h5 id="443"><a href="#443" class="headerlink" title="443"></a>443</h5><p>题意：in-place 压缩数组，如<code>&quot;abccccd&quot; -&gt; &quot;abc4d&quot;</code></p>
<p>解法：根据前一个字符是否等于当前字符判断是否需要继续构造答案，另外需要考虑结尾的边界</p>
<h5 id="445"><a href="#445" class="headerlink" title="445"></a>445</h5><p>题意：不翻转链表，完成链表求和，返回链表</p>
<p>解法：好像没有空间 O(1)的解法，链表拿出来存到支持随机访问的容器（或者用栈）即可，另外从讨论区学到一种写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>    List&lt;Integer&gt; lst1 = toList(l1);<br>    List&lt;Integer&gt; lst2 = toList(l2);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lst1.size() - <span class="hljs-number">1</span>, j = lst2.size() - <span class="hljs-number">1</span>, carry = <span class="hljs-number">0</span>; i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || carry != <span class="hljs-number">0</span>; i--, j--) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) now += lst1.get(i);<br>        <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">0</span>) now += lst2.get(j);<br>        now += carry;<br>        carry = now / <span class="hljs-number">10</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(now % <span class="hljs-number">10</span>);<br>        tmp.next = ret;<br>        ret = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title function_">toList</span><span class="hljs-params">(ListNode now)</span> &#123;<br>    List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (now != <span class="hljs-literal">null</span>) &#123;<br>        ans.add(now.val);<br>        now = now.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="446"><a href="#446" class="headerlink" title="446"></a>446</h5><p>题意：求数组中长度至少为 3 的等差子序列的数量</p>
<p>解法：<br>dfs：时间复杂度 O(2^N)<br>dp：用 map 存以当前数字结尾，差为 d 的、长度至少为 2 的子序列数量，对每个数字遍历之前已经处理过的所有数字，可得长度至少为 3 的子序列数量，同时更新当前数字结尾的字典</p>
<p>另外需要注意 diff 超出 int 范围时的处理</p>
<h5 id="447"><a href="#447" class="headerlink" title="447"></a>447</h5><p>题意：求这样的 tuple (i,j,k)的个数，使得 distance(Point[i], Point[j]) &#x3D;&#x3D; distance(Point[i], Point[k])，点的个数不超过 500，坐标绝对值不超过 10000</p>
<p>解法：O(n^2)计算所有距离即可</p>
<h5 id="448"><a href="#448" class="headerlink" title="448"></a>448</h5><p>题意：数组中数字的值域为[1,arr.length]，有些数字出现两次，有些出现一次，找出所有值域范围内缺失的整数值，要求输出外使用 O(1)空间</p>
<p>解法一：数组内用值做下标的循环赋值问题<br>解法二：来自讨论区，对所有见过的值，对其应该存在的下标位置置为负值，最终那些仍存储正数的下标就是未见过的值，相当于利用数字的正负储存信息，利用了原数组没有将 int 值域填满的特性</p>
<h5 id="449"><a href="#449" class="headerlink" title="449"></a>449</h5><p>题意：二叉搜索树的序列与反序列化</p>
<p>解法：如果按照二叉树序列化会比较简单，考虑利用搜索树的特性，在没有子节点时不需要通过特殊字符标注结束，下一个节点值 val 会在出栈至 val 处于当前节点 upperBound 与 lowerBound 之间时加入</p>
<h5 id="450"><a href="#450" class="headerlink" title="450"></a>450</h5><p>题意：二叉树节点删除</p>
<p>解法：分为当前节点是要删除的节点与不是两种情况，当前节点是要删除的节点时根据是否有儿子分为几种情况，在递归中传递当前节点，返回当前节点作为树根的、删除需要删除的节点后的树根。纯靠记忆。</p>
<h5 id="451"><a href="#451" class="headerlink" title="451"></a>451</h5><p>题意：字符序列根据出现频率排序，如 abcaac -&gt; aaaccb</p>
<p>解法：带 index 排序</p>
<h5 id="452"><a href="#452" class="headerlink" title="452"></a>452</h5><p>题意：一维空间中有多个区间，看做“气球”，使用最少的针扎破所有气球，每个针只用一次</p>
<p>解法一：按区间结束位置排序，维护一根针能够覆盖的最远位置（由于已经按结束位置排序，实际上不需要维护，每根针遇到的第一个气球的结束位置就是最小结束位置，也即最远覆盖位置），每当出现起始位置大于这根针能够覆盖的最远位置的情况，需要多分配一根针</p>
<p>解法二：打散每个气球的起始结束为如下数据结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Event</span>&#123;<br>    <span class="hljs-type">int</span> index;<br>    <span class="hljs-type">int</span> place;<br>    <span class="hljs-type">boolean</span> isStart;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用两个 set 分别维护当前针覆盖的气球编号、已经扎破的气球编号，遇到结束事件时，如果还未扎破，那么需要分配新针，对当前针进行总结。另外需要考虑在同一位置有开始与结束的情况。这个方法更直观，虽然都是 O(n)但是比方法一要慢几倍</p>
<h5 id="453"><a href="#453" class="headerlink" title="453"></a>453</h5><p>题意：每次可以对数组中除一个元素以外的所有元素加一，求最少多少次 move 可以使数组中全部元素相等</p>
<p>解法：等价于某元素减一</p>
<h5 id="454"><a href="#454" class="headerlink" title="454"></a>454</h5><p>题意：四个数组，问是否存在每个数组取一个元素使得和为 0</p>
<p>解法一：O(n^3)，同 3Sum 解法，不同数组也可以用双指针<br>解法二：类似于归并，分成两组，每组 O(n^2)时间计算所有可能的和，最后 O(n)进行匹配</p>
<h5 id="455"><a href="#455" class="headerlink" title="455"></a>455</h5><p>题意：给小孩分饼干，每个小孩有满足度，每个饼干有 size，每个小孩只能给一块饼干，求最多能够满足多少小孩。</p>
<p>解法：排序后贪心分即可</p>
<h5 id="456"><a href="#456" class="headerlink" title="456"></a>456</h5><p>找出数组中是否存在这样的 index i j k，使 arr[j] &gt; arr[k] &gt; arr[i]</p>
<p>解法一：遍历 ijk 中的 j（也就是 index from 1 to arr.length - 2），左侧维护一个最小值，右侧使用红黑树（TreeMap）每次 logn 查询小于 arr[j]的最大值，总体 nlogn</p>
<p>解法二：从右往左扫，维护一个以当前下标 j 对应的 arr[j]为栈顶的单增栈，和栈中第二大元素 third，每次新来的数字如果小于 third，那么找到 132 模式，否则 pop 直到 nums[j] &gt; stack.top()，更新 third，插入 nums[j]。代码来自讨论区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">find132pattern</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length, top = n, third = Integer.MIN_VALUE;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] &lt; third) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (top &lt; n &amp;&amp; nums[i] &gt; nums[top]) third = nums[top++];<br>        nums[--top] = nums[i];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="457"><a href="#457" class="headerlink" title="457"></a>457</h5><p>题意：数组中的元素代表向前&#x2F;后跳的距离，问是否存在大小大于 1 的环，环中的跳跃只能是单向的。要求 O(n)时间 O(1)空间。</p>
<p>解法：首先对数组取模使得所有元素小于数组长度，然后使用一个自增 id 代表当前序号，遍历数组尝试跳跃，对访问过的元素进行染色，如果能够走到已经染色的位置说明有环。需要注意单向、环长度不为 1 的情况。</p>
<h5 id="458"><a href="#458" class="headerlink" title="458"></a>458</h5><p>之前的理解有问题，TODO</p>
<!-- 题意：用n只猪试毒，k瓶水中一瓶有毒，每次尝试需要x分钟，共有y分钟的时间，给定k、x、y，求能够确保测出的最小的n

解法：数学题，一开始的想法是对水编码，所有猪每次尝试试出有毒的水在这一编码下某一位的值，n头猪最多可以试(n+1)^k瓶水（k = floor(y / x)。但是还有更好的办法。对水进行编码，编码进制由尝试次数+1决定，编码位数由猪的个数决定（每头猪负责编码中的一位），在尝试次数用完时这头猪正好能够测出含毒的水编码后这一位上的序号，n头猪可以试出(k+1)^n瓶水。

显然有k>=1，对于可变的n来说，长远来看(k+1)^n一定大于(n+1)^k，问题转化为在n较小时，是否存在(n+1)^k > (k+1)^n。尴尬的是，这种情况是存在的……当k=2,n=2。可能是题目有问题，发了个post（链接
），希望能够解释的朋友可以回复一下。 -->

<h5 id="459"><a href="#459" class="headerlink" title="459"></a>459</h5><p>题意：问给出的字符串是否是某个子串的重复（重复至少一次）</p>
<ul>
<li>解法一：for 最小重复片段长度，for 每个字符是否匹配，复杂度 O(n^2)</li>
<li>解法二：利用未优化的 kmp buildNext 方法求 next 数组，如果存在循环节一定有 dp[n] !&#x3D; 0 &amp;&amp; dp[n] % (n-dp[n]) &#x3D;&#x3D; 0，第二个条件保证了模板串后缀与与模板串前缀的匹配相交（避免 abefgab），并且模板串长度是不相交部分的长度的整数倍（避免 abcdabcdab），这样利用后缀与前缀相等的性质能够证明存在重复子串。</li>
<li>解法三：</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">repeatedSubstringPattern</span>(<span class="hljs-params">self, <span class="hljs-built_in">str</span></span>):<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">2</span> * <span class="hljs-built_in">str</span>)[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<p>存在循环节的情况下令循环节为 A，不失一般性 S&#x3D;AA，上述代码构造 XAAY，XY 分别为 A 掐头去尾后的产物，显然在存在循环节的情况下成立。考虑不存在循环节的情况（这个我没想出为什么一定不存在，先咕了）<br>(本题参考了<a target="_blank" rel="noopener" href="https://blog.csdn.net/huanghanqian/article/details/77620952">这里</a>的解释)</p>
<h5 id="525"><a href="#525" class="headerlink" title="525"></a>525</h5><p>最长子数组，使得其中0、1数量相同。维护前缀、dict，key&#x3D;每个index前缀0和1之差，dict为index，相同差总是前缀越短越好，遍历时即计算前缀、dict，也统计答案</p>
<h5 id="679-24点"><a href="#679-24点" class="headerlink" title="679 24点"></a>679 24点</h5><p>backtrack，最后math.round(n, 5)防止精度问题</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/24-game/discuss/1374182/Python-Easy-95-Runtime-Memoization-with-Comments">https://leetcode.com/problems/24-game/discuss/1374182/Python-Easy-95-Runtime-Memoization-with-Comments</a></p>
<h5 id="698"><a href="#698" class="headerlink" title="698"></a>698</h5><p>尝试数组分为等大小的N份，因为无法确定随便找到的一个组合会不会影响其他组合，所以只能backtrack</p>
<p>剪枝很重要，可以作为backtrack练习题</p>
<h5 id="696"><a href="#696" class="headerlink" title="696"></a>696</h5><p>没能一次做出easy，惭愧</p>
<h5 id="772"><a href="#772" class="headerlink" title="772"></a>772</h5><p>leetcode的收费，可以在这里做<br><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/849/description">https://www.lintcode.com/problem/849/description</a></p>
<p>加减乘除括号计算器</p>
<p>开括号递归 闭括号结束递归，化为只有加减乘除的情况，只有乘除立即计算，减化为加，退出时退栈加和<br>如何判断数字结束：最后一个位置，或者符号(+-*&#x2F;)</p>
<p>每当遇到符号结算一次，结算后将当前符号填入。结束递归，或字符串遍历完成后，需要对操作数栈求和返回</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> c == <span class="hljs-string">&quot;+&quot;</span> <span class="hljs-keyword">or</span> c == <span class="hljs-string">&quot;-&quot;</span> <span class="hljs-keyword">or</span> c == <span class="hljs-string">&quot;*&quot;</span> <span class="hljs-keyword">or</span> c == <span class="hljs-string">&quot;/&quot;</span>:<br>    <span class="hljs-keyword">if</span> prevOp == <span class="hljs-string">&quot;+&quot;</span>:<br>        vals.append(now)<br>    <span class="hljs-keyword">elif</span> prevOp == <span class="hljs-string">&quot;-&quot;</span>:<br>        vals.append(-now)<br>    <span class="hljs-keyword">elif</span> prevOp == <span class="hljs-string">&quot;*&quot;</span>:<br>        vals[-<span class="hljs-number">1</span>] *= now<br>    <span class="hljs-keyword">elif</span> prevOp == <span class="hljs-string">&quot;/&quot;</span>:<br>        vals[-<span class="hljs-number">1</span>] //= now<br>    now = <span class="hljs-number">0</span> <span class="hljs-comment"># 还原当前数字</span><br>    op = c <span class="hljs-comment"># 用当前op覆盖</span><br></code></pre></td></tr></table></figure>

<h5 id="862"><a href="#862" class="headerlink" title="862"></a>862</h5><p><strong>需要复习</strong></p>
<p>提交 <a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/668624489/">https://leetcode.com/submissions/detail/668624489/</a></p>
<p>求和至少为 K 的最短子数组，和209是一道题，只是这里数字不一定是正数。提交的代码上只相差一个while（两行），用于维护单调队列</p>
<p>构造前缀和</p>
<p>解法不是普通队列（或者说是一个窗口）而是单调队列</p>
<p>遍历前缀和数组，当前访问的位置是a，同时维护备选的前缀和b，从a-b中寻找答案，显然，index越大但和更小的前缀和作为减数更有优势</p>
<p>因此维护的是单调递增队列</p>
<p>如果有index大且prefix小的，那么可以淘汰</p>
<p>每次找队列左侧，其值最小，应当是第一个满足大于等于K的位置，如果满足，循环pop看后面的位置能否满足（因为更短）</p>
<h5 id="880"><a href="#880" class="headerlink" title="880"></a>880</h5><p>s &#x3D; “leet2code3”, k &#x3D; 10<br>遇到字符代表往变量append字符，遇到n代表复制当前字符至n倍长度，求第k个字符，index从1开始</p>
<p>记录</p>
<ol>
<li>每次翻倍前和翻倍后的长度 base[i] repeat[i]</li>
<li>当前长度cur</li>
<li>每次增量的字符串</li>
</ol>
<p>每读一个字符后，判定一次cur是否超过k，如果当前是字符，直接返回，如果是翻倍导致的，那么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py3">i = len(segs) - 1<br>k -= 1<br>while True:<br>    k %= base[i] # 简化到不重复的场景<br>    if i == 0:<br>        return segs[0][k]<br>    elif k &gt;= repeat[i - 1]: # 如果k落在增量串中<br>        return segs[i][k - repeat[i - 1]]<br>    else:<br>        i -= 1 # 如果k落在之前的重复串中，继续迭代<br></code></pre></td></tr></table></figure>

<h5 id="1172-Dinner-Plate-Stacks"><a href="#1172-Dinner-Plate-Stacks" class="headerlink" title="1172. Dinner Plate Stacks"></a>1172. Dinner Plate Stacks</h5><p>给出一个List[Stack]，List无限长，Stack容量给定，支持从最左侧未满的Stack add，从最右侧未空的Stack pop、从任意index的Stack pop</p>
<p>我的做法：考虑使用链表维护notEmpty和notFull的index，在任意index pop场景，为了尽快获得某index左右的node，使用TreeMap，总体思路是notEmpty和notFull两个双向链表，链表内维护一个index到node的treeSet，最后一个用例挂了，数据太大没法手动调，放弃</p>
<p>ref: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/dinner-plate-stacks/discuss/367554/Java-O(logn)-Operations-Using-List-and-TreeSet">https://leetcode.com/problems/dinner-plate-stacks/discuss/367554/Java-O(logn)-Operations-Using-List-and-TreeSet</a><br>维护一个List[Stack]和一个Treeset，Treeset按index顺序存储未满且（不在最右侧+此index empty）的index</p>
<p>插入：如果set为空（所有非最右+empty的位置都满了，使用最右+empty），否则使用treeset.first() index的位置，如果插满了，treeset.remove<br>任意index pop：先检查是否有数据，Treeset.add(index)。最后使用while清理所有处于最右侧且empty的index，将其从List[Stack]与Treeset中删除</p>
<p>TreeSet中不存最右侧+empty的原因在于，pop时可以直接使用set.last()找到第一个不为空的位置。</p>
<p>总结一下，这个实现确保了Treeset的第一个元素是可插入的（或者如果没有可插入index的话，Treeset为空），确保了Treeset的最后一个元素所在index不是空的。这种在中间插入的问题很难用Hashmap解决。</p>
<p>O(NlogN)复杂度</p>
<h5 id="1239"><a href="#1239" class="headerlink" title="1239"></a>1239</h5><p>backtrack</p>
<h5 id="1304"><a href="#1304" class="headerlink" title="1304"></a>1304</h5><p>注意下是unique</p>
<h5 id="1420-Build-Array-Where-You-Can-Find-The-Maximum-Exactly-K-Comparisons"><a href="#1420-Build-Array-Where-You-Can-Find-The-Maximum-Exactly-K-Comparisons" class="headerlink" title="1420. Build Array Where You Can Find The Maximum Exactly K Comparisons"></a>1420. Build Array Where You Can Find The Maximum Exactly K Comparisons</h5><p>N个数字的正数数组，从第一个数字作为起点，严格递增序列的最大长度为K，数组中元素最大值小于等于M，求这样数组的个数</p>
<p>dp[i][j][k]，i -&gt; 数组长度，j -&gt; 严格递增序列最大长度，k -&gt; 数组中最大元素值</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># ref: https://leetcode.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/discuss/586733/Python-7-liner-DP-without-using-DFS</span><br><span class="hljs-comment"># 状态转移</span><br>dp[i][j][k] = <br>    dp[i-<span class="hljs-number">1</span>][j][k] * k <span class="hljs-comment"># dp[i-1][j][k]已经满足，新的元素加在最后，有k中选择。这里我们定义的dp第一维必须指的是前缀长度i-1，否则新加入的数字无法满足上述转移关系，follow-up: 如果是严格递减序列，直到最后一个元素，那么dp第一维度指的是后缀长度i-1 </span><br>  + dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>][l] <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, k) <span class="hljs-comment"># 如果需要新加入的数字来增长序列长度</span><br><br><span class="hljs-comment"># 初始状态</span><br>dp = [[[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(M + <span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(K + <span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N + <span class="hljs-number">1</span>)]<br>dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][l] <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, M + <span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i [<span class="hljs-number">1</span>-N]<br>  <span class="hljs-keyword">for</span> j [<span class="hljs-number">1</span>-K]<br>    dp[i][j][k] += [i-<span class="hljs-number">1</span>][j][k] * k<br>    <span class="hljs-keyword">for</span> k [<span class="hljs-number">1</span>-M]:<br>      dp[i][j][k] += dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][k]<br><br><span class="hljs-comment"># result</span><br><span class="hljs-built_in">sum</span>(dp[N][K][:]) % (<span class="hljs-number">10</span> * <span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br></code></pre></td></tr></table></figure>

<h5 id="1448"><a href="#1448" class="headerlink" title="1448"></a>1448</h5><p>树搜索，维护路径最大值，简单</p>
<h5 id="1647"><a href="#1647" class="headerlink" title="1647"></a>1647</h5><p>统计字母频率，处理时不需要记录ans以外的任何中间信息，如果有冲突，ans++，freq–，重试</p>
<h5 id="1799-Maximize-Score-After-N-Operations"><a href="#1799-Maximize-Score-After-N-Operations" class="headerlink" title="1799. Maximize Score After N Operations"></a>1799. Maximize Score After N Operations</h5><p>给N*2个数字，两两搭配，每个搭配计算gcd获得一个得分，共N个得分，按1-N加权，求和的最大值</p>
<p>暴力backtrack 获得不重复的所有组合，算最大值</p>
<p>缓存gcd结果作用不大</p>
<p>更快的做法：缓存子数组的解，ans &#x3D; Max(ans, 任取两个数*（数组长度&#x2F;2）+ solve(数组删掉这两个数))，缓存solve(数组)的结果，返回solve（nums）即答案</p>
<p>mark-red: 加权使得我们必须考虑组合的顺序，即在当前一趟的dfs中遍历选择的组合 与 在稍后轮次的dfs中遍历到的组合 之间的顺序是重要的。不妨为当前轮次dfs中选择的组合赋予当前最大权值，其余部分只能使用更小的权值（权值范围的最大值 也是其余部分可以预见到的最大权值）这使得子问题可缓存</p>
<p>mark-red follow up: 如果不加权呢（显然问题更简单了）dfs时必须保证当前数字被消耗，即gcd的第一个数字所在index前不得有未使用的数字。如果仍然像上面那样，由于组合之间的顺序在这里不再重要，在一轮dfs中遍历所有组合会导致很多等价的组合数组，是没有必要的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs py3">class Solution:<br>    def maxScore(self, nums: List[int]) -&gt; int:<br>        # brute force with memorization<br>        <br>        # states<br>        mem = &#123;&#125;<br>        <br>        # helper<br>        def cal_score(arr):<br>            nonlocal mem<br>            # base<br>            n = len(arr)<br>            if n == 0: return 0<br>            target = tuple(arr)<br>            if target in mem: return mem[target]<br>            # find all valid pairs<br>            maxscore = 0<br>            for i in range(n):<br>                for j in range(i+1, n):<br>                    copy = list(arr)<br>                    a, b = arr[i], arr[j]<br>                    copy.remove(a)<br>                    copy.remove(b)<br>                    score = math.gcd(a, b) * (n//2) + cal_score(copy)<br>                    maxscore = max(maxscore, score)<br>            mem[target] = maxscore<br>            return maxscore<br>        <br>        return cal_score(nums)<br></code></pre></td></tr></table></figure>

<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><ol start="69">
<li>二分</li>
<li>DP</li>
<li>维护一个存储最简路径的 ArrayList 即可</li>
<li>DP，初始状态<ol>
<li>两个空串使用 0 费用即可匹配</li>
<li>只有一个串不为空，需要串长度费用<br>递推：dp[i]][j]代表仅考虑s1[i] s2[j]时的情况，无论对s1添加还是删除，均转为删除的情况，s1添加等于s2删除，此外考虑s1[i]&#x3D;&#x3D;s2[j]的情况</li>
</ol>
</li>
<li>总是假设一个堆（如最小堆）的大小不小于另一个堆的大小，且中位数（依赖1或2个数字）一定通过两堆顶就可得知。需要考虑的case：最小堆顶数为3，最大堆顶数为2，大小相等，由于假设最小堆总是更大，插入新数后最小堆应更大，考虑新数为-100，显然是不能直接放到最小堆的，<strong>这种情况应当插入最大堆后从最大堆平衡元素到最小堆</strong>。<br>也可以这么看，两个堆分别是已经见过的数字的大的和小的一半，<strong>对于新的数字，首先需要先决定插入那一半后，对两个堆的大小进行平衡操作</strong><br><a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/688005887/">https://leetcode.com/submissions/detail/688005887/</a></li>
<li>a[i]+b[0] for i in len(a)放到最小堆，不断从堆中拿出并加入答案，同时放回a[i]，b[j+1]去排序<br><a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/316575016/">https://leetcode.com/submissions/detail/316575016/</a></li>
<li>ref <a target="_blank" rel="noopener" href="https://leetcode.com/problems/count-the-repetitions/submissions/">https://leetcode.com/problems/count-the-repetitions/submissions/</a></li>
<li>iterative计算子串，对每个字符，计算以当前字符为结尾的串的数量。对于重复的情况，维护单调递增的“以当前字符c结尾的串”的最长长度即可<br>我的 80%：<a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/688174425/">https://leetcode.com/submissions/detail/688174425/</a><br>逻辑简化版 96%：<br>LC-CN题解：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string/solution/xi-fa-dai-ni-xue-suan-fa-yi-ci-gao-ding-qian-zhui-/">https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string/solution/xi-fa-dai-ni-xue-suan-fa-yi-ci-gao-ding-qian-zhui-/</a></li>
<li>两个TreeMap维护前半A和后半部分B，A的任意元素大于B的任意元素，新元素先加入A，随后将A的最小元素pop加入B，B的size总是增长的，因此每次需要判断是否需要将B的元素交给A。删除窗口外元素时需要在AB中尝试。存下标即可<br><a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/693017669/">https://leetcode.com/submissions/detail/693017669/</a><br>Treemap相对于堆的优势在于支持从排序容器的两端删除&#x2F;查找元素，可以用相同的思路做第295题，但会发现其常数比堆大很多<br><a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/693028788/">https://leetcode.com/submissions/detail/693028788/</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zuma-game/solution/gong-shui-san-xie-yi-ti-shuang-jie-sou-s-3ftb/1221358">https://leetcode-cn.com/problems/zuma-game/solution/gong-shui-san-xie-yi-ti-shuang-jie-sou-s-3ftb/1221358</a></li>
<li>重点在于如何去重，下方的提交给了一个不用去重的手段<br><a target="_blank" rel="noopener" href="https://leetcode.com/submissions/detail/695674480/">https://leetcode.com/submissions/detail/695674480/</a><br>而我自己常用的手法是对一个元素讨论是否将其加入结果 list 中</li>
</ol>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>msft <a target="_blank" rel="noopener" href="https://leetcode.com/problems/encode-string-with-shortest-length/">https://leetcode.com/problems/encode-string-with-shortest-length/</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%8A%80%E6%9C%AF/" class="category-chain-item">技术</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">#数据结构与算法</a>
      
        <a href="/tags/%E5%8A%A0%E5%AF%86/">#加密</a>
      
        <a href="/tags/%E6%80%BB%E7%BB%93/">#总结</a>
      
        <a href="/tags/%E5%88%B7%E9%A2%98/">#刷题</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>LeetCode题目简短总结</div>
      <div>https://vicety.github.io/2018/12/12/LeetCode题目简短总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>vicety</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2018年12月12日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/12/12/Luogu%203372.%20%E7%BA%BF%E6%AE%B5%E6%A0%91/" title="Luogu 3372. 线段树">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Luogu 3372. 线段树</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/12/12/Microsoft%E7%AE%97%E6%B3%95%E9%A2%98/" title="MS算法题总结">
                        <span class="hidden-mobile">MS算法题总结</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"p7Skzx1UifgNosmr5ms2nILv-gzGzoHsz","appKey":"W73NSV1s3dRPtfceJDBsX5uP","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
