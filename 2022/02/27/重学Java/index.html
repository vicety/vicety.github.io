

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/vicety/Images@master/images/momiji-ico.ico">
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/vicety/Images@master/images/momiji-ico.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="vicety">
  <meta name="keywords" content="">
  
    <meta name="description" content="TODO 合并 .&#x2F;draft&#x2F;虚拟机.md 到本文件TODO Java各版本的改进 https:&#x2F;&#x2F;openjdk.org&#x2F;projects&#x2F;jdk&#x2F; 什么是JavaJCP (Java Community Process) 定义Java技术体系包含以下几个部分：  Java程序设计语言 各种平台的JVM实现 Class文件格式（就是字节码？） Java类库 第三方Java类库">
<meta property="og:type" content="article">
<meta property="og:title" content="重学Java">
<meta property="og:url" content="https://vicety.github.io/2022/02/27/%E9%87%8D%E5%AD%A6Java/index.html">
<meta property="og:site_name" content="vicety的博客">
<meta property="og:description" content="TODO 合并 .&#x2F;draft&#x2F;虚拟机.md 到本文件TODO Java各版本的改进 https:&#x2F;&#x2F;openjdk.org&#x2F;projects&#x2F;jdk&#x2F; 什么是JavaJCP (Java Community Process) 定义Java技术体系包含以下几个部分：  Java程序设计语言 各种平台的JVM实现 Class文件格式（就是字节码？） Java类库 第三方Java类库">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/vicety/Images/master/images20151217151455512.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/vicety/Images@master/images/20200222090333.png">
<meta property="og:image" content="https://raw.githubusercontent.com/vicety/Images/master/images24788834-d344228375a28112.png">
<meta property="og:image" content="https://raw.githubusercontent.com/vicety/Images/master/images20220902105708.png">
<meta property="og:image" content="https://pic3.zhimg.com/v2-25db3af7c97be0fed6b926e1c1650a96_r.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-5b2d953ff1d98335e9ad87d7edb00bc3_r.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/vicety/Images/master/images20151217151455512.jpg">
<meta property="og:image" content="https://s2.51cto.com/images/blog/202112/31104829_61ce6f7db613373977.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=">
<meta property="article:published_time" content="2022-02-27T11:42:00.000Z">
<meta property="article:modified_time" content="2023-03-12T19:42:00.254Z">
<meta property="article:author" content="vicety">
<meta property="article:tag" content="加密">
<meta property="article:tag" content="编程语言">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/vicety/Images/master/images20151217151455512.jpg">
  
  
  
  <title>重学Java - vicety的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"vicety.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 90vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>vicety的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://raw.githubusercontent.com/vicety/Images/master/images91426832_p0.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="重学Java"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-02-27 12:42" pubdate>
          2022年2月27日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          25k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          207 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">重学Java</h1>
            
            
              <div class="markdown-body">
                
                <p>TODO 合并 .&#x2F;draft&#x2F;虚拟机.md 到本文件<br>TODO Java各版本的改进 <a target="_blank" rel="noopener" href="https://openjdk.org/projects/jdk/">https://openjdk.org/projects/jdk/</a></p>
<h2 id="什么是Java"><a href="#什么是Java" class="headerlink" title="什么是Java"></a>什么是Java</h2><p>JCP (Java Community Process) 定义Java技术体系包含以下几个部分：</p>
<ol>
<li>Java程序设计语言</li>
<li>各种平台的JVM实现</li>
<li>Class文件格式（就是字节码？）</li>
<li>Java类库</li>
<li>第三方Java类库</li>
</ol>
<h2 id="JVM内存划分"><a href="#JVM内存划分" class="headerlink" title="JVM内存划分"></a>JVM内存划分</h2><p>（注意不能叫做JMM，JMM是与线程间同步相关的规范）</p>
<p>根据JVM spec，JVM管理的内存会被这样划分：<br>线程共享：</p>
<ol>
<li>方法区：[4]class字节流的常量池、属性表、方法表和异常表（注意Class对象是在heap中的）<br>hotspot使用元空间实现方法区，元空间使用本地内存，即不受JVM内存限制<br>ref: <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/358312524/answer/965401488">https://www.zhihu.com/question/358312524/answer/965401488</a></li>
<li>堆：一块大内存而已，但我们需要更好的管理方式，细节见GC小节</li>
</ol>
<p>线程独占：</p>
<ol>
<li>程序计数器</li>
<li>虚拟机栈：为使用字节码表示的方法服务，方法被执行时创建帧栈，栈帧包括：局部变量表、操作数栈、动态链接与返回地址<ul>
<li>返回地址作用：函数调用结束后，退回调用方的下一条指令继续执行<br> ref: <a target="_blank" rel="noopener" href="https://gitbook.coder.cat/function-call-principle/content/function-stack-frame.html">https://gitbook.coder.cat/function-call-principle/content/function-stack-frame.html</a></li>
<li>TODO：什么是动态链接</li>
</ul>
</li>
<li>本地方法栈：为native方法服务</li>
</ol>
<p>TODO Java是否只GC堆，方法区呢</p>
<p>什么是native memory&#x2F;off-heap：占用JVM进程内存空间，（但JVM不管理这部分内存？？存疑）<br>TODO <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/30622818/what-is-the-difference-between-off-heap-native-heap-direct-memory-and-native-m">这里</a></p>
<p>方法区：处于native memory（还有什么区使用native memory吗）<br>TODO [这里](<a target="_blank" rel="noopener" href="https://dzone.com/articles/java-8-permgen-metaspace#:~:text=The%20JDK%208%20HotSpot%20JVM%20is%20now%20using%20native%20memory%20for%20the%20representation%20of%20class%20metadata%20and%20is%20called%20Metaspace%3B%20similar%20to%C2%A0the%20Oracle%20JRockit%20and%20IBM%20JVM%27s">https://dzone.com/articles/java-8-permgen-metaspace#:~:text=The%20JDK%208%20HotSpot%20JVM%20is%20now%20using%20native%20memory%20for%20the%20representation%20of%20class%20metadata%20and%20is%20called%20Metaspace%3B%20similar%20to%C2%A0the%20Oracle%20JRockit%20and%20IBM%20JVM%27s</a>.)</p>
<h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><h4 id="对象格式"><a href="#对象格式" class="headerlink" title="对象格式"></a>对象格式</h4><p>包括对象头（Mark Word + 指向klass对象的指针 + （可选 如果是数组类型）数组长度）、实例数据、Padding<br>TODO klass对象似乎就是class文件加载到jvm后的表示<br>TODO <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26222859/article/details/81335542">https://blog.csdn.net/qq_26222859/article/details/81335542</a></p>
<p>Mark Word如下[3]，根据锁标志位不同，存储内容的解释方式也不同（32位虚拟机的markword长32bit，64位的长64bit）<br><img src="https://raw.githubusercontent.com/vicety/Images/master/images20151217151455512.jpg" srcset="/img/loading.gif" lazyload></p>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>TODO [3 ch2]</p>
<p>两种方案</p>
<ul>
<li>已占用的内存在同一端：分配内存等于移动已占用内存位置指针</li>
<li>空闲与占用内存交错：空闲列表</li>
</ul>
<h5 id="TLAB与栈上分配"><a href="#TLAB与栈上分配" class="headerlink" title="TLAB与栈上分配"></a>TLAB与栈上分配</h5><p>ref: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/myseries/p/12884249.html">https://www.cnblogs.com/myseries/p/12884249.html</a><br>一般在java程序中，new的对象是分配在堆空间中的，但是实际的情况是，大部分的new对象会进入堆空间中，而并非是全部的对象，还有另外两个地方可以存储new的对象，我们称之为栈上分配以及TLAB</p>
<ul>
<li>栈上分配：经常对象的声明周期仅在方法内，此时将对象分配在栈上，从而实现随着函数退出的出栈而自动销毁，两点优势：<ol>
<li>减少堆内存分配的竞争（考虑多个线程并发请求分配内存，需要通过同步确保它们不会分配到相同位置），也能够加快分配速度</li>
<li>减少gc负担</li>
</ol>
</li>
<li>TLAB：每个线程在Eden空间内预先分配一小块内存，小对象可以直接从这里分配空间，而不用考虑对堆加锁，提高空间分配效率</li>
</ul>
<p>栈上分配在技术上依赖逃逸分析与标量替换，二者缺一不可，可以参考这里的实验<br>标量替换：JVM不直接创建对象，而是等价地创建对象的不可继续分割的成员<br><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1863058">https://cloud.tencent.com/developer/article/1863058</a><br>我的猜测是，栈应当是固定大小的，只有替换为标量</p>
<p>分配流程优先级：</p>
<ol>
<li>栈上分配</li>
<li>TLAB分配</li>
<li>老年代或Eden</li>
</ol>
<h2 id="Class文件格式、字节码"><a href="#Class文件格式、字节码" class="headerlink" title="Class文件格式、字节码"></a>Class文件格式、字节码</h2><p>TODO 参考[3]，这块还需要重新整理</p>
<ul>
<li>magicNumber</li>
<li>Class文件版本</li>
<li>常量池<ul>
<li>字面量：文本字符串、final常量值</li>
<li>符号引用：字段&#x2F;方法的名称与描述符（描述符包括字段类型、方法参数、返回值）、类的全限定名、方法句柄等等</li>
</ul>
</li>
<li>类或接口的访问标志：是否public，是否是接口&#x2F;注解&#x2F;枚举、是否是final类等等</li>
<li>字段表：包括访问标志、名称（指向常量池的一个索引），描述符（字段类型，是指向常量池的索引）、属性表<ul>
<li>属性表：包括方法内代码的字节码、异常处理、最大栈深度、行号等等</li>
</ul>
</li>
<li>方法表：与字段表类似</li>
</ul>
<h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><blockquote>
<p>Java虚拟机采用 面向操作数栈而不是面向寄存器的架构（这两种架构的执行过程、区别和影响将在第8章中探讨），所<br>以大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中[3]</p>
</blockquote>
<p>字节码分如下几类</p>
<ul>
<li>加载与存储指令：iload（int变量从局部变量表加载到操作数栈）、istore（int变量从操作数栈加载到局部变量表）、bipush（常量加载到操作数栈）</li>
<li>运算指令：加减乘除、位运算、比较</li>
<li>类型转换指令：用于处理窄化类型转换，如long转int，而int转long是不需要字节码支持的[3]</li>
<li>对象创建与访问：new、newarray、（访问类）getfield、putfield、getstatic、putstatic</li>
<li>操作数栈管理：pop、pop2、dup、dup2、swap（交换栈顶两个元素）</li>
<li>控制转移：ifeq、goto</li>
<li>方法调用与返回：invoke[virtual|interface|special|static|dynamic]、iretur（不同数据类型的return）</li>
<li>异常处理：athrow</li>
<li>同步指令：monitor[enter|exit]</li>
</ul>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>省流：<br>包括这几个阶段：加载、验证、空间分配、链接、初始化、使用、卸载</p>
<ul>
<li>加载：字节码转 Class 对象</li>
<li>验证：与class文件等价的字节流可能不是通过javac产生的，可能会绕过一些问题的检查（如引用无法找到的类等），因此需要校验</li>
<li>空间分配：静态变量</li>
<li>链接：对常量池的引用由符号引用替换为直接引用</li>
<li>初始化：静态变量初始化、静态代码块</li>
</ul>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>省流：用于帮助 JVM 从文件系统中找到类的二进制（字节码）表示，并转换为 Class 对象<br>TODO 双亲委派的设计理念，目前的理解是保护高优先级类（原生类）不被覆盖</p>
<p>Question：什么是类加载<br>Answer：把符号名映射为内存中类的二进制表示的过程</p>
<blockquote>
<p>JLS 12.2. Loading of Classes and Interfaces<br>Loading refers to the process of finding the binary form of a class or interface type with a particular name<br>…<br>and constructing, from that binary form, a Class object to represent the class or interface.</p>
</blockquote>
<p>Question：什么是类加载器</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.baeldung.com/java-classloaders">https://www.baeldung.com/java-classloaders</a><br>Class loaders are responsible for loading Java classes dynamically to the JVM (Java Virtual Machine) during runtime.<br>Furthermore, these Java classes aren’t loaded into memory all at once, but rather when they’re required by an application.</p>
</blockquote>
<p>上述链接中还包括三种不同 ClassLoader 何时被使用的例子，分别是 <code>MyClass</code>, <code>Logging</code>, <code>ArrayList</code></p>
<blockquote>
<p>This bootstrap class loader is part of the core JVM and is written in native code (即不是 Java 写的)<br>The extension class loader is a child of the bootstrap class loader, and takes care of loading the extensions of the standard core Java classes<br>The system or application class loader, on the other hand, takes care of loading all the application level classes into the JVM.</p>
</blockquote>
<p>Question: Bootstrap ClassLoader 是 native code 的，那么谁加载了其余两个 ClassLoader 呢？<br>Answer：省流：就是 Bootstrap Classloader<br>TL;DR</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/a/47324515/8454039">https://stackoverflow.com/a/47324515/8454039</a><br>As of Java 8, both, AppClassLoader and ExtClassLoader, are subclasses of java.net.URLClassLoader, which is a subclass of java.security.SecureClassLoader, which is a subclass of java.lang.ClassLoader. All of these classes are loaded by the Bootstrap loader, solving the chicken-and-egg problem.</p>
</blockquote>
<p>Question: 谁负责加载 主类 （即程序启动命令 java SomeClass 中的 SomeClass），如何决定其他类由谁加载？</p>
<p>省流：Application Class Loader 加载 Main 类，对于类 A 中引用的 其他类（或 Class.forName 调用），由加载 类A 的加载器负责完成加载动作</p>
<blockquote>
<p>[7]<br>Each runtime class has a defining class loader (笔者注：通过 getClassLoader() 拿到). For those classes defined by the Bootstrap loader during startup, the defining class loader is the Bootstrap loader. When the JVM initialization is completed and an attempt to start an application is made, &#x3D;&#x3D;the Application class loader (aka System class loader) will be queried for the main class.&#x3D;&#x3D;<br>…<br>Now, &#x3D;&#x3D;when resolving a class referenced by another class or when Class.forName(String) is invoked, the defining loader of the class containing the reference will be used to resolve the class&#x3D;&#x3D;.</p>
</blockquote>
<blockquote>
<p>So when the Application class loader has loaded your class myapp.foo.Bar and it contains a reference to javax.swing.JButton, its defining class loader, i.e. the Application class loader, will be queried for that class, follow the delegation model to end up with a javax.swing.JButton defined by the Bootstrap loader. So class references within javax.swing.JButton are resolved only through the Bootstrap loader, which implies that javax.swing.JButton can not contain a reference to your myapp.foo.Bar class, as it is not in scope.</p>
</blockquote>
<p>Question：是否有办法实现主动类卸载</p>
<p>场景：REPL redefinition<br>Answer：没有，仅当 ClassLoader 被 GC 时，Class 表示会被卸载，<a target="_blank" rel="noopener" href="https://stackoverflow.com/a/148707/8454039">参考</a></p>
<h4 id="破坏双亲委派"><a href="#破坏双亲委派" class="headerlink" title="破坏双亲委派"></a>破坏双亲委派</h4><p>省流：<strong>当我们需要在 Java 内置类 中加载应用类时，会需要打破默认的类加载逻辑</strong></p>
<p>先回顾 类加载 流程伪代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># canonical class name</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loadClass</span>(<span class="hljs-params">name:<span class="hljs-built_in">str</span>, resolve:<span class="hljs-built_in">bool</span></span>):<br>    c:Class = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> notAlreadyLoaded(name):  <br>        <span class="hljs-keyword">if</span> parent:<br>            c = parent.localClass(name, false)<br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># Bootstrap ClassLoader (the uppermost classloader)</span><br>            c = findBootstrapClassOrNull(name)<br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> c:<br>            <span class="hljs-comment"># may throw throws ClassNotFoundException</span><br>            c = findClass(name)<br><br>        <span class="hljs-comment"># guaranteed c not None here</span><br>    <span class="hljs-keyword">if</span> resolve:<br>        <span class="hljs-comment"># linking phase, see JLS 12.3. Linking of Classes and Interfaces</span><br>        resolveClass(c)<br>    <span class="hljs-keyword">return</span> c<br></code></pre></td></tr></table></figure>

<p>Question: 为什么会需要破坏双亲委派<br>[7]给出的例子中，若业务代码引用了 <code>javax.swing.JButton</code>，它会被 Bootstrap Classloader 加载，而 <code>javax.swing.JButton</code> 内部定义的类，由于上述伪代码描述的加载逻辑，是不可能能够成功加载业务代码中定义的类的。<strong>当我们需要在 Java 内置类 中加载应用类时，会需要打破默认的类加载逻辑。</strong></p>
<p>[loc 1] 给出了一个网上常见的例子，通过 <code>DriverManager.getConnection(url, &quot;root&quot;, &quot;password&quot;);</code> 可以拿到 JDBC 连接，这意味着 Java 内置的 DriverManger 代码要能够返回一个 DB 方定义的 SomeDBConnection 实例，这就是上面提到的需要打破类加载机制的 case。</p>
<p>具体实现利用了 Java 提供的 SPI 机制，这里先介绍 SPI 机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设ISpeak接口来自 io.github.vicety 包</span><br>ServiceLoader&lt;ISpeak&gt; speakers = ServiceLoader.load(ISpeak.class);<br><span class="hljs-keyword">for</span> (ISpeak speaker : speakers) &#123;<br>    speaker.speak();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>传入我们需要用来找实现类的接口（相当于传一个配置），获得对应的 ServiceLoader instance，这是一个迭代器，迭代时会根据我们创建它时传入的配置，也就是接口的全限定名 <code>io.github.vicety.ISpeak</code>，搜索 classpath 下所有 jar包 内的 META-INF&#x2F;services&#x2F;io.github.vicety.ISpeak 文件，文件中会存放实现类的全限定名，并通过 <code>Class.forName</code> 加载它，通过 <code>Class.newInstance</code> + <code>Class.cast</code> 创建实例并转化为接口类型返回给用户使用</p>
<p>虽然看起来是 Java 内部代码帮我们加载了这个类，实际上则是 ServiceLoader 创建时记录了 <code>Thread.currentThread().getContextClassLoader();</code>，一般是 Applicaiton ClassLoader，后续的 <code>Class.forName</code> 也是使用这个类加载器加载，实际上并没有破坏双亲委派</p>
<p>回到 DriverManager 的例子，其源码摘录重点如下。主要的逻辑就是当 DriverManager 被加载时，在静态块中利用 SPI 机制初始化所有实现 <code>Driver</code> 接口的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>    loadInitialDrivers();<br>        ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);<br>        Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();<br>        <span class="hljs-keyword">while</span>(driversIterator.hasNext())<br>            driversIterator.next();<br>    println(<span class="hljs-string">&quot;JDBC DriverManager initialized&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但这还不够，接着看 [loc 3] 中介绍的 <code>Driver</code> 接口实现类的实现，核心逻辑是主动将自身实例 <code>new Driver()</code> 注册到 DriverManager 的容器中，后续调用 <code>DriverManager.getConnection</code> 时会使用这个容器中的实例尝试进行连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NonRegisteringDriver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.sql.Driver &#123;<br>    <span class="hljs-keyword">static</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            java.sql.DriverManager.registerDriver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>());  <br>        &#125; <span class="hljs-keyword">catch</span> (SQLException E) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Can&#x27;t register driver!&quot;</span>);  <br>        &#125;  <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>TODO dubbo、spring 的例子？看下这些例子有什么不同吗？</p>
<p>参考文章：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7007292903361871903">https://juejin.cn/post/7007292903361871903</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hollischuang/p/14260801.html">https://www.cnblogs.com/hollischuang/p/14260801.html</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013679744/article/details/56298283">https://blog.csdn.net/u013679744/article/details/56298283</a></li>
</ol>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>与class文件等价的字节流可能不是通过javac产生的，可能会绕过一些问题的检查（如引用无法找到的类等），因此需要校验</p>
<blockquote>
<p>JLS 12.3.1. Verification of the Binary Representation<br>Verification ensures that the binary representation of a class or interface is structurally correct. For example, it checks that every instruction has a valid operation code; that every branch instruction branches to the start of some other instruction, rather than into the middle of an instruction;</p>
</blockquote>
<h3 id="准备（分配空间）"><a href="#准备（分配空间）" class="headerlink" title="准备（分配空间）"></a>准备（分配空间）</h3><p>为静态变量分配空间。注意静态变量与Class对象都在堆中。[3] 7.3.3节</p>
<blockquote>
<p>JLS 12.3.2. Preparation of a Class or Interface Type<br>Preparation involves creating the static fields (class variables and constants) for a class or interface and initializing such fields to the default values (§4.12.5). This does not require the execution of any source code; explicit initializers for static fields are executed as part of initialization (§12.4), not preparation.</p>
</blockquote>
<h3 id="解析（符号引用替换为直接引用）"><a href="#解析（符号引用替换为直接引用）" class="headerlink" title="解析（符号引用替换为直接引用）"></a>解析（符号引用替换为直接引用）</h3><p>将class字节流常量池中的符号引用替换为直接引用</p>
<blockquote>
<p>JLS 12.3.3. Resolution of Symbolic References<br>The binary representation of a class or interface references other classes and interfaces and their fields, methods, and constructors symbolically<br>…<br>Before a symbolic reference can be used it must undergo resolution, wherein a symbolic reference is checked to be correct and, typically, replaced with a direct reference that can be more efficiently processed if the reference is used repeatedly.</p>
</blockquote>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>编译器收集类变量（应该就是静态变量）赋值与静态块，合并产生<code>&lt;clinit&gt;</code>方法，在此阶段被调用</p>
<blockquote>
<p>JLS 12.4. Initialization of Classes and Interfaces<br>Initialization of a class consists of executing its static initializers and the initializers for static fields (class variables) declared in the class.<br>Initialization of an interface consists of executing the initializers for fields (constants) declared in the interface.</p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>好像没什么可以介绍的</p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><blockquote>
<p>A class or interface may be unloaded if and only if its defining class loader may be reclaimed by the garbage collector<br>Classes and interfaces loaded by the bootstrap loader may not be unloaded.<br>Class unloading is an optimization that helps reduce memory use. Obviously, the semantics of a program should not depend on whether and how a system chooses to implement an optimization such as class unloading.</p>
</blockquote>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>网上的说法Java默认是1:1线程，面试中有聊到更新的JVM已经是N:M，待考证</p>
<h3 id="线程状态机"><a href="#线程状态机" class="headerlink" title="线程状态机"></a>线程状态机</h3><p>From <code>Thread.java</code><br>NEW RUNNALE RUNNING BLOCKED WAITING TIMED_WAITING TERMINATED</p>
<p><img src="https://cdn.jsdelivr.net/gh/vicety/Images@master/images/20200222090333.png" srcset="/img/loading.gif" lazyload><br>(图源：<a target="_blank" rel="noopener" href="https://blog.csdn.net/pange1991/article/details/53860651">https://blog.csdn.net/pange1991/article/details/53860651</a>)</p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><blockquote>
<p>[6]The memory model determines what values can be read at every point in the program.</p>
</blockquote>
<blockquote>
<p>[6]The Java programming language memory model works by examining each read in an execution trace and checking that the write observed by that read is valid according to certain rules.</p>
</blockquote>
<p>总结一下，JMM规定了read允许读到的write值</p>
<p>[3]JMM屏蔽了各种硬件和操作系统的内存访问差异，实现了让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C和C++等）直接使用物理硬件和操作系统的内存模型。因此，由于 不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发<br>访问却经常出错，所以在某些场景下必须针对不同的平台来编写程序</p>
<h3 id="《深入理解JVM》一书中的描述"><a href="#《深入理解JVM》一书中的描述" class="headerlink" title="《深入理解JVM》一书中的描述"></a>《深入理解JVM》一书中的描述</h3><p>笔者发现本书中的描述与JLS中的略有不同，因此分别列出</p>
<h4 id="内存交互操作的规则"><a href="#内存交互操作的规则" class="headerlink" title="内存交互操作的规则"></a>内存交互操作的规则</h4><p>JMM定义了主内存与工作内存的概念，对于主内存与工作内存的交互，JMM定义了八种操作：</p>
<ul>
<li>lock、unlock 将变量表示为线程独占、取消标记</li>
<li>read：变量值从主内存读到工作内存，供load使用</li>
<li>load：将read拷贝进来的值赋给工作内存中的变量副本</li>
<li>use：将工作内存中一个变量的值传递给执行引擎，当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作</li>
<li>assign：执行引擎赋值给工作内存变量</li>
<li>store：工作内存变量值拷贝到主内存，供稍后的write使用</li>
<li>write：将store拷贝到主内存的变量值赋给主内存变量</li>
</ul>
<p>JMM定义了对上述操作的一些限制，下方列出部分最有用的规则，全文可以参考《深入理解JVM》，比较难理解，稍后介绍等价的happen-before原则来替代这些规则</p>
<ol>
<li>JMM要求read load, store write必须同时出现且按顺序执行（不一定是连续执行）。</li>
<li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量 前，需要重新执行load或assign操作以初始化变量的值</li>
</ol>
<h4 id="volatile变量的规则"><a href="#volatile变量的规则" class="headerlink" title="volatile变量的规则"></a>volatile变量的规则</h4><p>对volatile变量的写入，从汇编上表示为相邻的mov与lock两条指令。lock指令会将处理器缓存写入内存，同时会无效化其他处理器的对应缓存行，实现变量可见性。同时，lock还有<strong>内存屏障</strong>的作用，指令重排无法跨越屏障</p>
<p>考虑如下场景，doInit与initialized无因果可见关系，因此如果initialized非volatile，是允许initilized赋值排序到doInit前的，可能导致threadB使用未初始化完成的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// threadA</span><br>doInit();<br>initialized = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// threadB</span><br><span class="hljs-keyword">while</span> (!initialized) &#123;<br>  sleep(<span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="final变量的规则"><a href="#final变量的规则" class="headerlink" title="final变量的规则"></a>final变量的规则</h4><p>（来自《深入理解JVM》）<br>被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值</p>
<h4 id="Happen-Before原则"><a href="#Happen-Before原则" class="headerlink" title="Happen-Before原则"></a>Happen-Before原则</h4><p>Happen-Before Order是JLS向Java用户提供的执行顺序保证，或者说，发生在前的动作产生的结果确保能够被发生在后的动作观察到</p>
<ul>
<li>程序次序原则：同一线程内，执行流顺序在前的动作Happen-Before执行流在后的动作</li>
<li>管程锁定规则：对同一个锁的unlock操作Happen-Before对这个锁的时间上发生在后的lock操作</li>
<li>volatile变量规则：对volatile变量的写Happen-Before时间上发生在后的、对这个变量的读</li>
<li>线程启动规则：Thread.start() Happen-Before此线程内的任何动作</li>
<li>线程终止规则：线程中任何动作都Happen-Before检测到线程终止（通过Thread::isalive, Thread::join等）</li>
<li>线程中断规则：intterupt的调用Happen-Before检测到中断事件的发生（通过Thread::interrupted）</li>
<li>对象终结规则：对象构造函数执行结束Happen-Before其finialize方法的开始</li>
<li>传递性</li>
</ul>
<h3 id="JLS中的描述"><a href="#JLS中的描述" class="headerlink" title="JLS中的描述"></a>JLS中的描述</h3><p>JLS原文见[6]</p>
<p>所有的instance fields、static fields and arrays都存储在共享的heap memory<br>Java 9 引入的local variable（通过<code>var</code>声明）、形参（formal parameter）、以及exception handler参数从不在线程间共享</p>
<p>TODO 没找到线程内部的顺序保证…</p>
<h3 id="基于JMM规则，回答一些问题"><a href="#基于JMM规则，回答一些问题" class="headerlink" title="基于JMM规则，回答一些问题"></a>基于JMM规则，回答一些问题</h3><h5 id="volatile可以确保单个变量的可见性，如何确保数组index修改的可见性？"><a href="#volatile可以确保单个变量的可见性，如何确保数组index修改的可见性？" class="headerlink" title="volatile可以确保单个变量的可见性，如何确保数组index修改的可见性？"></a>volatile可以确保单个变量的可见性，如何确保数组index修改的可见性？</h5><p>回答1：利用管程锁定规则、传递性。对读取加锁，这样的话，根据规则有读取Happen-After lock，lock Happen-After写入动作的unlock，这样读取Happen-After写入，根据Happen-Before定义，确保了可见性<br>总结：对于单个变量的线程间共享，可以使用volatile或加锁，多个变量的情况（数组或复合类型）只能用锁<br>追问：那使用LockSupport&#x2F;Unsafe.park&#x2F;unpark不行吗<br>回答2：见下方问题</p>
<h5 id="LockSupport-park-x2F-unpark与happen-before的关系？"><a href="#LockSupport-park-x2F-unpark与happen-before的关系？" class="headerlink" title="LockSupport.park&#x2F;unpark与happen-before的关系？"></a>LockSupport.park&#x2F;unpark与happen-before的关系？</h5><p>Park（native方法）调用过程中会调用<code>OrderAccess::fence()</code>方法，从下方[localref 1]可以看到汇编指令与volatile是非常相似的<code>__asm__ volatile (&quot;lock; addl $0,0(%%rsp)&quot; : : : &quot;cc&quot;, &quot;memory&quot;);</code>（关于三个冒号的作用可以去看内嵌汇编相关的资料，也可以参考[localref 4]，深入了解推荐[localref 5]）</p>
<p>猜测park也有与volatile一样写回内存的作用。重新考虑上面问题的<code>回答1</code>，因为写回内存，可以看做任何之后的操作都Happen-After，因此park可以有管程的语义<br>TODO 存疑</p>
<p>TODO 似乎park和synchronized有相同的语义，怎么证明呢</p>
<h5 id="synchronized与基于AQS的同步类如何确保可见性"><a href="#synchronized与基于AQS的同步类如何确保可见性" class="headerlink" title="synchronized与基于AQS的同步类如何确保可见性"></a>synchronized与基于AQS的同步类如何确保可见性</h5><p>synchronized通过<code>管程锁定规则</code>确保<br>基于AQS的同步类，在调用AQS的lock、unlock时，实际上是修改了AQS的volatile state变量，volatile的写入会导致工作内存flush回主内存，同时invalidate其他线程的对应缓存行</p>
<p>参考<br>reentrantlock如何保证可见性？ - 圆圆要努力变强的回答 - 知乎<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/41016480/answer/1630071673">https://www.zhihu.com/question/41016480/answer/1630071673</a></p>
<h5 id="总结线程安全类设计范式"><a href="#总结线程安全类设计范式" class="headerlink" title="总结线程安全类设计范式"></a>总结线程安全类设计范式</h5><p>AtomicInteger: CAS+volatile<br>ArrayBlockingQueue: ReentrantLock+Condition<br>ConcurrentHashMap: volatile+CAS+synchronized<br>TODO 其实有点好奇对于链表的情况怎么确保不读到过时值</p>
<p>参考</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903729380982797#heading-3">https://juejin.cn/post/6844903729380982797#heading-3</a></li>
<li><a target="_blank" rel="noopener" href="https://www.shouxicto.com/article/2713.html">https://www.shouxicto.com/article/2713.html</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/137460543">https://zhuanlan.zhihu.com/p/137460543</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/26456510/what-does-asm-volatile-do-in-c">https://stackoverflow.com/questions/26456510/what-does-asm-volatile-do-in-c</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43526907">https://zhuanlan.zhihu.com/p/43526907</a></li>
</ol>
<h3 id="线程安全实现方法总结"><a href="#线程安全实现方法总结" class="headerlink" title="线程安全实现方法总结"></a>线程安全实现方法总结</h3><p>Java通过以下方式实现线程安全</p>
<ol>
<li>不可变对象：如String</li>
<li>无状态对象：只依赖传入参数，无内部状态</li>
<li>加锁同步（Synchronized、AQS系列（Park&#x2F;Unpark））</li>
<li>无锁同步（CAS）</li>
</ol>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收实际上就是内存管理问题</p>
<p>前文介绍了JVM内存划分，其中线程自有的部分：虚拟机栈随着函数调用进行扩缩容（本地方法栈应当也是类似的），PC不会占用多少空间，随着线程的结束而回收，这部分内存的管理是相对trival的，下面我们主要讨论方法区与堆的垃圾回收</p>
<ul>
<li>引用计数：无法解决循环引用问题</li>
<li>可达性分析：<br>从GCRoot开始寻找强引用连接的对象，作为GCRoot的对象可以分为全局引用与执行上下文，具体如下：<ul>
<li>虚拟机栈中引用的对象（方法参数、局部变量）</li>
<li>方法区的静态变量</li>
<li>方法区常量（如常量池中的字符串）</li>
<li>被synchronized锁住的对象</li>
<li>在本地方法栈中JNI方法（即native方法）引用的对象</li>
<li>虚拟机内部对象（如基本类型、常驻异常的Class对象，系统类加载器）</li>
<li>反应JVM内部情况的（详情见《深入JVM》）<br>宣告对象死亡，至少需要两次回收：第一次根据RC Root标记对象，未被引用且未重写finalize方法的对象宣告死亡，有finalize的对象加入一个集合，尝试执行其finalize方法，但不保证执行或执行完成，稍后对此集合重新分析可达性，如果仍然不可达，宣告死亡</li>
</ul>
</li>
</ul>
<p>四种引用类型，提出它们目的在于向JVM与用户提供一种介于保留与可回收之间的引用语义</p>
<ul>
<li>强引用</li>
<li>软引用：在产生内存溢出异常之前，允许回收仅被软引用指向的对象</li>
<li>弱引用：生存到下次GC前</li>
<li>虚引用：虚引用对对象的生存周期不造成任何影响，get方法永远返回null，在配合队列使用时能够实现在回收前得到一个通知（并没有用过）</li>
</ul>
<p>方法区回收</p>
<ul>
<li>方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。废弃常量的判断相对容易，而对于不再使用的类型，我需要阅读更多资料，先跳过</li>
<li>方法区的回收收益远不如堆的回收收益</li>
<li>对于大量使用字节码框架（反射、动态代理、CGLib）的场景，方法区回收也许是必要的</li>
</ul>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><ul>
<li><p>大多数对象的生存时间很短</p>
</li>
<li><p>存活时间越久的对象，越能存活更久</p>
</li>
<li><p>Baseline 标记清除：问题在于内存碎片</p>
</li>
<li><p>标记复制：内存分为相等大小的两部分，gc后，存活的对象复制到另一部分，下次gc前空间也仅在另一部分分配</p>
<ul>
<li>问题：尽管相等大小保证回收后一定装得下，但通常只有很少一部分对象会存活<br>以Parallel GC为例，策略是8:1:1（细节略过，因为我会），老年代兜底</li>
</ul>
</li>
<li><p>标记整理：存活对象向内存的一侧移动</p>
</li>
<li><p>标记清除：不整理，代价是内存碎片</p>
</li>
</ul>
<p>权衡是否移动对象：不移动对象导致内存碎片需要通过空闲列表来维护，使得分配复杂度上升；移动对象使得GC复杂度上升</p>
<p>内存分配策略：<br>对象优先在年轻代分配，大对象或在年轻代多次存活的对象直接分配到老年代。需要确保如果年轻代回收后大于10%空间，多出来的要放到老年代</p>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>Question：枚举GC Root需要STW吗？</p>
<blockquote>
<p>[3 ch3.4.1] 迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的</p>
</blockquote>
<h4 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h4><p>Question：Java有用三色标记吗？Go有分代吗<br>ref: <a target="_blank" rel="noopener" href="https://juejin.cn/post/7052966096583786510">https://juejin.cn/post/7052966096583786510</a></p>
<blockquote>
<p>Go的GC目前使用的是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动和整理）、并发（与用户代码并发执行）的三色标记清扫算法<br>TODO</p>
</blockquote>
<p>GC Root枚举总是需要STW Stop the World的，目的是避免并发修改引用关系</p>
<ol>
<li>gc时设置标志位，程序检测到这个标志位时中断执行</li>
<li>为了不影响性能，只在少量位置检测这个标志位<br>TODO OopMap</li>
<li>分代收集中，回收年轻代时，需要考虑跨代指针。为了避免在整个老年代中寻找GC Root，引入卡表，它使用一个byte数组维护内存区域（卡页）内是否有跨代指针。JVM会intercept引用修改事件，将卡表对应位置置位。</li>
<li>有了RC Root之后，可以遍历获得所有被引用的对象，但仍然存在并发修改引用关系的问题，为了最小化停顿时间，我们可以对gc期间的并发修改进行<strong>记录</strong>（这部分相对于整个堆肯定还是很小的），整体扫描过一遍后，停顿处理这些并发的修改。</li>
</ol>
<p>实际上使用的算法如下，引入三色标记，算法的主要部分可以理解为一个BFS，三种节点如下：</p>
<ul>
<li>黑色：节点被GC访问过，扇出已经全部加入BFS队列</li>
<li>灰色：被作为某节点的扇出（或GC Root）加入BFS队列，但尚未被pop的节点</li>
<li>白色：其他节点</li>
</ul>
<p><img src="https://raw.githubusercontent.com/vicety/Images/master/images24788834-d344228375a28112.png" srcset="/img/loading.gif" lazyload alt="Go语言大厂编程 GC内存回收 https://juejin.cn/post/7052966096583786510"></p>
<p>GC期间对引用关系的修改可能会导致回收正在使用的对象，如图：</p>
<p><img src="https://raw.githubusercontent.com/vicety/Images/master/images20220902105708.png" srcset="/img/loading.gif" lazyload alt="[3] ch3.4.6"></p>
<p>规范化的解释是，GC期间当</p>
<ol>
<li>新增了黑色到某白色的引用</li>
<li>删除了所有从黑色到此白色的引用<br>二者同时满足时，会导致与GC Root连通的白色对象被回收</li>
</ol>
<p>破坏上述任意一个条件都可以避免问题，因此有两种策略，都需要对GC期间的引用关系修改做intercept：</p>
<ol>
<li>新增黑色到白色的的引用关系时，将白色节点加入重新标记集合</li>
<li>删除灰色到白色的引用关系时，将白色节点加入重新标记集合</li>
</ol>
<p>Question: 网上的资料总是提到的 <strong>写屏障</strong> 是什么？<br>其实就是修改引用关系是做的intercept</p>
<h4 id="三色标记法-深入"><a href="#三色标记法-深入" class="headerlink" title="三色标记法 - 深入"></a>三色标记法 - 深入</h4><p>两种策略的最终目标如下：</p>
<ol>
<li>强三色不变式<br>不存在黑色对象引用到白色对象的指针</li>
<li>弱三色不变式<br>所有被黑色对象引用的白色对象都处于灰色保护状态，即这种白色对象总是（不经过黑色对象）可达某个灰色对象</li>
</ol>
<h5 id="Dijkstra-write-barrier"><a href="#Dijkstra-write-barrier" class="headerlink" title="Dijkstra write barrier"></a>Dijkstra write barrier</h5><p>目的是通过满足<strong>强三色不变式</strong>保证GC期间的并发引用修改不导致回收使用中的对象，实现上是对指针写操作做intercept，核心逻辑是 <strong>被添加引用的对象标记为灰色</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// slot=原先指向，ptr=将要指向</span><br>(slot, ptr) =&gt; &#123;<br>    <span class="hljs-comment">// shade(ptr) marks the object at ptr grey if it is not already grey or black. </span><br>    shade(ptr)<br>    *slot = ptr<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上假设ptr已经是黑色的了（可能导致未引用对象未被回收，但确保引用对象一定不回收）。所有节点的状态都是单调（白灰黑）的，使得GC复杂度bounded by heap size</p>
<p>实现上，[local 1]指出对栈上元素做intercept成本很高，因此将栈上元素的扫描推迟到STW的（也就是不会发生指向变化的）重新标记阶段做，当然代价是提升了重新标记阶段的STW时间，尤其是go routine多的情况下</p>
<h5 id="Yuasa-style-deletion-write-barrier"><a href="#Yuasa-style-deletion-write-barrier" class="headerlink" title="Yuasa-style deletion write barrier"></a>Yuasa-style deletion write barrier</h5><p>目的是通过满足<strong>弱三色不变式</strong>保证GC期间的并发引用修改不导致回收使用中的对象，实现上是对指针写操作做intercept，核心逻辑是 <strong>被删除引用的对象标记为灰色</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// slot=原先指向，ptr=将要指向</span><br>(slot, ptr) =&gt; &#123;<br>    <span class="hljs-comment">// 如果slot已经是黑色，标记为（回退为）灰色只会增加GC复杂度</span><br>    <span class="hljs-comment">// shade(ptr) marks the object at ptr grey if it is not already grey or black. </span><br>    shade(ptr)<br>    slot = ptr<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>即下图中需要对 对象5 标记为灰色，同时注意到，对象5 的极大连通分量其实是应当被回收的。<br>另一种直观解释认为这种策略相当于对GC开始瞬间的对象拓扑结构（或者说，GC开始瞬间对引用拓扑结构做的快照）进行保留</p>
<p>这种策略实际上没有在Golang中被使用，我的理解，下方解释图中在栈上的写屏障只是为了说明功能，实际上在栈上使用的应该还是有代价过高的问题的</p>
<p>TODO 为什么？<br><img src="https://pic3.zhimg.com/v2-25db3af7c97be0fed6b926e1c1650a96_r.jpg" srcset="/img/loading.gif" lazyload alt="ref [2]"></p>
<h5 id="Hybrid-write-barrier"><a href="#Hybrid-write-barrier" class="headerlink" title="Hybrid write barrier"></a>Hybrid write barrier</h5><p>第一种（插入写屏障）的问题在于需要利用引用关系不变的STW时间完成从栈上对象开始的扫描<br>第二种（删除写屏障）的问题在于GC不会回收GC开始瞬间的所有存活对象（即使它们在GC期间被并发修改为不可达对象）</p>
<p>引入 混合写屏障</p>
<ol>
<li>GC开始时，栈上所有对象标记黑色</li>
<li>GC期间在栈上创建的对象标记为黑色</li>
<li><strong>被添加引用的对象标记为灰色</strong></li>
<li><strong>被删除引用的对象标记为灰色</strong></li>
<li>屏障（也就是下方函数）仍仅在堆上应用</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// slot=原先指向，ptr=将要指向</span><br>(slot, ptr) =&gt; &#123;<br>    <span class="hljs-comment">// shade(ptr) marks the object at ptr grey if it is not already grey or black. </span><br>    shade(slot)<br>    shade(ptr)<br>    slot=ptr<br>&#125;<br></code></pre></td></tr></table></figure>

<p>图解案例分析，强烈推荐看[local 2]，这里放其中一个例子说明为什么 删除写屏障 的规则是必要的，直观上的原因是因为栈上不加写屏障（也就是intercept。</p>
<p>由于栈上不intercept，断开 4-&gt;7 的操作如果只有 <strong>被添加引用的对象标记为灰色</strong> 这一条规则是不够的</p>
<p><img src="https://pic4.zhimg.com/v2-5b2d953ff1d98335e9ad87d7edb00bc3_r.jpg" srcset="/img/loading.gif" lazyload alt="ref [2]"></p>
<p>我的理解，栈上使用保守（时间效率高，回收效率低）的算法（全部标黑），避免重新标记阶段（即避免此阶段的STW）；由于栈上不重新标记，堆上需要同时 使用 插入写屏障 与 删除写屏障 的逻辑才能保证安全</p>
<h5 id="参考文章（三色标记法-深入）"><a href="#参考文章（三色标记法-深入）" class="headerlink" title="参考文章（三色标记法 - 深入）"></a>参考文章（三色标记法 - 深入）</h5><ol>
<li>想要了解细节，强烈建议阅读Golang引入混合写屏障的Proposal <a target="_blank" rel="noopener" href="https://go.googlesource.com/proposal/+/master/design/17503-eliminate-rescan.md">Proposal: Eliminate STW stack re-scanning</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/334999060">Golang三色标记+混合写屏障GC模式全分析 - 刘丹冰Aceld的文章 - 知乎</a></li>
</ol>
<h4 id="Java的各种垃圾回收器"><a href="#Java的各种垃圾回收器" class="headerlink" title="Java的各种垃圾回收器"></a>Java的各种垃圾回收器</h4><p>年轻代</p>
<ol>
<li>Serial：标记复制，STW</li>
<li>ParNew：标记复制，STW，多线程GC</li>
<li>Parallel Scavenge：标记复制，STW，多线程，可配置单次GC最大耗时，支持自适应调节新生代分区比例、晋升老年代对象大小等参数</li>
</ol>
<p>老年代</p>
<ol>
<li>Serial Old：标记整理，STW</li>
<li>Parallel Old：标记整理、STW、多线程GC</li>
<li>CMS（Concurrent Mark Sweep）：初始标记（RC Root）、并发标记、重新标记、并发清除。使用三色标记算法，仅初始标记与并发标记需要STW<br>TODO 补充它们的问题</li>
</ol>
<p>综合</p>
<ol>
<li>G1：（JDK 9以上的默认选项）：流程和CMS差不多，没有深入了解</li>
</ol>
<h4 id="Java垃圾回收的一些细节"><a href="#Java垃圾回收的一些细节" class="headerlink" title="Java垃圾回收的一些细节"></a>Java垃圾回收的一些细节</h4><p>主流JVM使用准确式垃圾收集，即虚拟机能够分辨内存中的某个位置的二进制数据时什么类型的，为了实现这一功能，引入一个叫做OOPMap的数据结构，考虑执行期间随时可能修改变量引用，因此仅在有限的位置才更新OOPMap的值，这个位置叫做<strong>安全点</strong>，仅在这个位置OOPMap的值是正确的，才允许进行GC，这样的位置通常在循环语句，目的是避免长时间无法到达可GC位置。此外，对于确保不会修改引用关系的区域（如线程挂起），在进入区域时也会通过标识自己进入<strong>安全区域</strong>来通知虚拟机，离开区域前检查是否在gc中，是则等待直到gc结束<br>OOPMap的理解参考了 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/346602242/answer/1378567282">https://www.zhihu.com/question/346602242/answer/1378567282</a></p>
<p>任何Partial GC都需要考虑对象被Partial外的对象引用的问题，我们需要找到收集区域外指向收集区域内的指针，将含有指针的对象（或者指针指向的对象）加入GC Root。Hotspot采用一个折中精度的做法：卡表，卡表可以简单地用一个数组表示，数组元素的值（0或1）代表一块内存内是否存在跨代指针。当修改对象引用时，JVM会intercept，将卡表对应位置置位。</p>
<ul>
<li>JIT生成的机器码也要同时生成卡表置位代码</li>
<li>False Sharing问题：多个卡表元素共享一个cache line，考虑并发修改的情况，如果一个元素被修改了，其他CPU的cache也会失效，导致需要重新从内存读，因此在修改前加上判断，仅当非脏才修改为脏标记（这么看来赋值是不会检查是否相等的，只要赋值，就会validate其他CPU的local cache）<blockquote>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/False_sharing">https://en.wikipedia.org/wiki/False_sharing</a> 链接中还给出了另一个cache false sharing的例子<br>false sharing is a performance-degrading usage pattern that can arise in systems with distributed, coherent caches at the size of the smallest resource block managed by the caching mechanism. When a system participant attempts to periodically access data that is not being altered by another party, but that data shares a cache block with data that is being altered, the caching protocol may force the first participant to reload the whole cache block despite a lack of logical necessity.</p>
</blockquote>
</li>
</ul>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>这里的锁指的是synchronized</p>
<ul>
<li>自适应自旋锁</li>
<li>锁消除：如果检测到加锁区域内的变量不会被其他线程访问到，那么没有必要加锁</li>
<li>锁粗化：如循环中的加锁<br>TODO 扩大区域会有可能导致死锁吗</li>
</ul>
<p>回忆Mark word<br><img src="https://raw.githubusercontent.com/vicety/Images/master/images20151217151455512.jpg" srcset="/img/loading.gif" lazyload></p>
<p>锁膨胀过程：无锁 - 偏向锁 - 轻量级锁 - 重量级锁</p>
<p>下方文字均来源于[5]</p>
<ul>
<li>偏向锁：当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时<strong>不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁</strong>。轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁<strong>只需要在置换ThreadID的时候依赖一次</strong>CAS原子指令即可。<br>升级条件：偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</li>
<li>轻量级锁：是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。<br>升级条件若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</li>
</ul>
<p>总结：<br><strong>偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞</strong>。<br>TODO Markword如何避免可见性问题？</p>
<h2 id="Java语法"><a href="#Java语法" class="headerlink" title="Java语法"></a>Java语法</h2><p>参考同文件夹下的 基础语法.md</p>
<h2 id="Java类库"><a href="#Java类库" class="headerlink" title="Java类库"></a>Java类库</h2><h3 id="java-lang"><a href="#java-lang" class="headerlink" title="java.lang"></a>java.lang</h3><h3 id="java-io"><a href="#java-io" class="headerlink" title="java.io"></a>java.io</h3><p>细节可以参考 [[Java-IO]]</p>
<p>IO包下的类有多重分类方式</p>
<ol>
<li>字节流（以Input&#x2F;OutputStream结尾）、字符流（以Reader&#x2F;Writer）结尾</li>
<li>节点流（虚类InputStream 子类FileInputStream）：直接与数据源相连；处理流（BufferedInputStream）：使用装饰器模式增强包装的节点流或处理流的功能<br><strong>装饰器模式</strong>：保持类方法签名完整性的前提下，提供了额外的功能</li>
<li>根据用途分类：文件操作（FileInput&#x2F;OutputStream、FileReader&#x2F;Writer）、管道操作（Java的管道用于线程通信）、数组操作（ByteArrayInput&#x2F;OutputStream、CharArrayReader&#x2F;Writer）、打印控制（PrintStream、PrintWriter）、转化控制（InputStreamReader、OutputStreamWriter）、对象序列化、基本数据类型操作、缓冲操作<br>ref: <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-03/#java-%E4%B8%AD-io-%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D">https://javaguide.cn/java/basis/java-basic-questions-03/#java-%E4%B8%AD-io-%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D</a><br>TODO 有些不知道作用</li>
</ol>
<p>问题：既然有了字节流,为什么还要有字符流<br>因为要根据不同编码从字节中decode出字符</p>
<h3 id="java-nio"><a href="#java-nio" class="headerlink" title="java.nio"></a>java.nio</h3><h3 id="java-util"><a href="#java-util" class="headerlink" title="java.util"></a>java.util</h3><p>参见 [[java.util 容器类]]</p>
<h3 id="java-util-concurrent"><a href="#java-util-concurrent" class="headerlink" title="java.util.concurrent"></a>java.util.concurrent</h3><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><p>推荐结合[2]与源码学习</p>
<p>TODO<br>AQS还定义了Condition Object，补充下这个<br>暂时的理解就是每个condition variable维护一个队列，signal后出队加入AQS的等待队列</p>
<ul>
<li>AQS内部维护一个volatile int state，基于它开发的类可以任意解释这个state，如ReentrantLock解释为重入次数，CountdownLatch解释为还有多少线程没有到达同步点。</li>
<li>AQS本身完全不依赖state的值，而是在调用acquire时 或 线程unpark苏醒后且自身在等待链表中是头结点的情况下 调用由子类实现的tryAcquire，由子类尝试操作state的值，并将是否acquire资源成功的结果返回给AQS</li>
<li>关于从等待链表中移除的时机</li>
<li>tryAcquire对</li>
<li>AQS没有实现tryAcquire&#x2F;tryRelease方法，一般的套路是（以ReentrantLock为例），类A的内部组合一个继承AQS的Sync类B，A暴露出的方法（如lock、countdown）直接交给Sync，如ReentrantLock公平锁的lock等价于sync.acquire，这个函数在AQS中已经实现。Acquire会先调用tryAcquire方法（Sync需要实现AQS的tryAcquire&#x2F;tryRelease方法），如果失败则使用Node代表当前线程，将Node添加到等待链表中，随后调用acquireQueued方法</li>
<li>acquired方法是一个死循环，不断检测当前节点是否在队头，是则调用tryAcquire尝试获得资源，如果失败，park挂起，直到由于其他线程调用release使得自身被unpark唤醒</li>
</ul>
<p>AQS保证等待链表中的线程，如果最终能够acquire到资源，一定按FIFO顺序acquire到。对于ReentrantLock非公平锁的实现，其底层是AQS，也是有这个限制的，它的实现请参考下方代码</p>
<p>ReentrantLock公平锁与非公平锁<br>NOTE：注意公平锁的定义是按请求资源的顺序获得资源，而不是在请求资源的所有请求方中随机选择</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FairSync 公平锁</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    acquire(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果资源未被抢占</span><br>        <span class="hljs-comment">// 如果等待链表为空，则CAS尝试抢占</span><br>        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>            compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 或者资源被抢占但是是自己抢的，重入</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 否则tryAcquire被跳过，当前线程加入等待链表，进入acquireQueued函数，在内部不断 被唤醒 - 检查条件 - 重新挂起（或者成功拿到资源，跳出循环）</span><br>&#125;<br><br><span class="hljs-comment">// NonFairSync 非公平锁</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>        setExclusiveOwnerThread(Thread.currentThread());<br>    <span class="hljs-keyword">else</span><br>        acquire(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果资源未被抢占</span><br>        <span class="hljs-comment">// 无论等待链表中是否有节点，都参与抢占，注意对比公平版本</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>AQS核心代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AQS类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="hljs-comment">// 插入链表后调用acquiredQueued</span><br>        selfInterrupt();<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 等待链表的header是dummy的，这也是为什么要拿到前置节点来判断是否是head</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node); <br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt()) <span class="hljs-comment">// 挂起</span><br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后以ReentrantLock为例，再看下release的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ReentrantLock实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125; <br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>(); <span class="hljs-comment">// 未获取到资源，却调用了tryRelease释放资源</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-literal">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br><br><br><span class="hljs-comment">// AQS实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>TODO shouldParkAfterFailedAcquire判断是否需要park的逻辑<br>TODO 节点状态，如CANCELLED &#x3D;  1; SIGNAL    &#x3D; -1; CONDITION &#x3D; -2; 等等</p>
<h4 id="一些面试问题"><a href="#一些面试问题" class="headerlink" title="一些面试问题"></a>一些面试问题</h4><h5 id="经常看到使用synchronized、ReentrantLock时不需要搭配volatile使用，为什么"><a href="#经常看到使用synchronized、ReentrantLock时不需要搭配volatile使用，为什么" class="headerlink" title="经常看到使用synchronized、ReentrantLock时不需要搭配volatile使用，为什么"></a>经常看到使用synchronized、ReentrantLock时不需要搭配volatile使用，为什么</h5><p>分synchronized和AQS两种情况</p>
<p>synchronized由于Happen-Before规则，保证下一次lock happen-after这一次的unlcok，又由于线程内的happen-before原则与happen-before的传递性，下一次lock后的逻辑一定能看到上一次unlock之前的所有动作</p>
<p>规则上：AQS利用volatile的Happen-Before规则为加解锁前后的代码制造happen-before关系<br>实现上：利用volatile变量写入时需要将工作内存中修改过的值写回主内存的特性实现<br>TODO 工作内存仍然是java定义的概念，我记得真正实现上是那个lock指令，内存屏障+禁止重排序</p>
<p>参考<br>reentrantlock如何保证可见性？ - 圆圆要努力变强的回答 - 知乎<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/41016480/answer/1630071673">https://www.zhihu.com/question/41016480/answer/1630071673</a></p>
<h5 id="ReentrantLock相比与synchronized"><a href="#ReentrantLock相比与synchronized" class="headerlink" title="ReentrantLock相比与synchronized"></a>ReentrantLock相比与synchronized</h5><p>提供公平&#x2F;非公平锁（synchronized 是非公平的，可以简单地通过代码验证）、支持等待被中断、支持多个条件（wait &#x2F; notify 只相当于支持一个条件）</p>
<h5 id="wait-x2F-notify-实现"><a href="#wait-x2F-notify-实现" class="headerlink" title="wait &#x2F; notify 实现"></a>wait &#x2F; notify 实现</h5><p><img src="https://s2.51cto.com/images/blog/202112/31104829_61ce6f7db613373977.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=" srcset="/img/loading.gif" lazyload alt="https://s2.51cto.com/images/blog/202112/31104829_61ce6f7db613373977.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk="></p>
<p>ref: <a target="_blank" rel="noopener" href="https://blog.51cto.com/NIO4444/5083741">https://blog.51cto.com/NIO4444/5083741</a></p>
<blockquote>
<p>调用wait方法，首先会获取监视器锁，获得成功以后，会让当前线程进入等待状态进入等待队列并且释放锁；</p>
</blockquote>
<blockquote>
<p>然后 当其他线程调用notify或者notifyall以后，会选择从等待队列中唤醒任意一个线程，而执行完notify方法以后，并不会立马唤醒线程，原因是当前的线程仍然持有这把锁，处于等待状态的线程无法获得锁。必须要等到当前的线程执行完按monitorexit指令以后，也就是锁被释放以后，处于等待队列中的线程就可以开始竞争锁了。</p>
</blockquote>
<p>TODO AQS Condition 模型似乎就可以看做 一个就绪队列 + 多个条件等待队列 的组合了（相比于上面的 wait &#x2F; notify 是一个就绪 + 一个条件）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从面试的角度总结一些常用考点</p>
<p>并发控制？<br>类加载过程？<br>对比 Java 与其他语言？什么是 Java 的优势？<br>什么是反射？为什么需要反射？<br>    如何声明，多种类型</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>[1]  <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-03.html#java-%E4%B8%AD-io-%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D">Java 中 IO 流分为几种</a><br>[2] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54297968">(JDK)ReentrantLock手撕AQS</a><br>[3] <a href="">《深入理解Java虚拟机》第三版</a><br>[4] <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/38496907/answer/271926577">hotpot java虚拟机Class对象是放在 方法区 还是堆中 ？ - EZLippi的回答 - 知乎</a><br>[5] <a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事</a><br>[6] <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html#jls-17.4">17.4. Memory Model</a><br>[7] <a target="_blank" rel="noopener" href="https://stackoverflow.com/a/47324515/8454039">classloader in java is a class itself then who will load the classloader class?</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%8A%80%E6%9C%AF/" class="category-chain-item">技术</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%8A%A0%E5%AF%86/">#加密</a>
      
        <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">#编程语言</a>
      
        <a href="/tags/Java/">#Java</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>重学Java</div>
      <div>https://vicety.github.io/2022/02/27/重学Java/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>vicety</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年2月27日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/03/%E9%87%8D%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="重学计算机网络">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">重学计算机网络</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/02/25/%E9%87%8D%E5%AD%A6%E6%95%B0%E6%8D%AE%E5%BA%93/" title="重学数据库">
                        <span class="hidden-mobile">重学数据库</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"p7Skzx1UifgNosmr5ms2nILv-gzGzoHsz","appKey":"W73NSV1s3dRPtfceJDBsX5uP","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
