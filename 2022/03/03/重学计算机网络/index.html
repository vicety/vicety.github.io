

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/vicety/Images@master/images/momiji-ico.ico">
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/vicety/Images@master/images/momiji-ico.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="vicety">
  <meta name="keywords" content="">
  
    <meta name="description" content="基于TCP-IP详解（卷一） 网络分层TODO  分不清802.3和以太网的区别  物理层：传输链路层报文，可以是有线传输（以太网），可以是无线传输（802.11）数据链路层：传输网络层协议（一般是IP协议）报文，在报文外封装链路层协议（如以太网协议，802.11协议）的header网络层：传输传输层协议报文，在报文外封装网络层协议header传输层：传输应用报文，在报文外封装传输层header应">
<meta property="og:type" content="article">
<meta property="og:title" content="重学计算机网络">
<meta property="og:url" content="https://vicety.github.io/2022/03/03/%E9%87%8D%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="vicety的博客">
<meta property="og:description" content="基于TCP-IP详解（卷一） 网络分层TODO  分不清802.3和以太网的区别  物理层：传输链路层报文，可以是有线传输（以太网），可以是无线传输（802.11）数据链路层：传输网络层协议（一般是IP协议）报文，在报文外封装链路层协议（如以太网协议，802.11协议）的header网络层：传输传输层协议报文，在报文外封装网络层协议header传输层：传输应用报文，在报文外封装传输层header应">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210301235624614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FydEFuZExpZmU=,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://raw.githubusercontent.com/vicety/Images/master/images20220330182912.png">
<meta property="article:published_time" content="2022-03-03T20:42:00.000Z">
<meta property="article:modified_time" content="2023-03-17T00:04:42.662Z">
<meta property="article:author" content="vicety">
<meta property="article:tag" content="加密">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20210301235624614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FydEFuZExpZmU=,size_16,color_FFFFFF,t_70#pic_center">
  
  
  
  <title>重学计算机网络 - vicety的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"vicety.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"TdxzU2OpwN7XHsa0T05Y01Kn-gzGzoHsz","app_key":"lfgF4JmupaIQkD5xRHAIBfTk","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 90vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>vicety的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://raw.githubusercontent.com/vicety/Images/master/images84327320_p0.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="重学计算机网络"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-03-03 21:42" pubdate>
          2022年3月3日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          101 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">重学计算机网络</h1>
            
            
              <div class="markdown-body">
                
                <p>基于TCP-IP详解（卷一）</p>
<h1 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h1><p>TODO</p>
<ol>
<li>分不清802.3和以太网的区别</li>
</ol>
<p>物理层：传输链路层报文，可以是有线传输（以太网），可以是无线传输（802.11）<br>数据链路层：传输网络层协议（一般是IP协议）报文，在报文外封装链路层协议（如以太网协议，802.11协议）的header<br>网络层：传输传输层协议报文，在报文外封装网络层协议header<br>传输层：传输应用报文，在报文外封装传输层header<br>应用层</p>
<p>其中：应用层与传输层是端到端的协议，意味着只有通信的两端需要使用到它们，剩余的层使用的是逐跳(hop-by-hop)的协议，意味着通信的两端以及任何路由都需要使用到它们</p>
<p>数据链路层与应用层的目的是显然的，分别用于对接物理层传输格式与应用通信格式<br>TODO 那么网络层与传输层呢</p>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>WLAN（Wireless Local Area Networks）</p>
<h3 id="网卡性能优化技术"><a href="#网卡性能优化技术" class="headerlink" title="网卡性能优化技术"></a>网卡性能优化技术</h3><p><strong>推荐</strong> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/mrwuzs/p/14636367.html">https://www.cnblogs.com/mrwuzs/p/14636367.html</a></p>
<p>TODO RSS技术 目的是将中断压力分摊到多个CPU<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangquan1992/article/details/117461737">https://blog.csdn.net/wangquan1992/article/details/117461737</a></p>
<h2 id="Header总结"><a href="#Header总结" class="headerlink" title="Header总结"></a>Header总结</h2><ol>
<li>以太网帧：MTU + src MAC 6 + dst MAC 6 + 类型 2 + CRC 4 &#x3D; MTU + 18 字节</li>
</ol>
<p>TODO<br>2. IP<br>3. TCP</p>
<h2 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h2><h3 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h3><p>MTU是链路层的概念，以太网等协议对链路层数据报文的长度有限制，以太网的限制是1500字节（不含以太网header）</p>
<p>MTU大了会增加并发的其他引用的时延，因为在物理层需要以链路层报文为基本单位串行传输<br>MTU小了会降低传输效率，同时链路层报文还要包含上层应用header的，这会进一步影响效率<br>ref: <a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/222535">https://developer.aliyun.com/article/222535</a></p>
<h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>TODO ARP报文格式</p>
<p>ARP协议负责将IP地址转化为MAC地址，过程如下：<br>ref: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28771785">https://zhuanlan.zhihu.com/p/28771785</a></p>
<blockquote>
<p>(书上的描述）ARP的功能是 在32 bit的I P地址和采用不同网络技术的硬件地址之间提供动态映射</p>
</blockquote>
<p>（我的理解，待确认，是否在同一网段是通过子网掩码判断的）</p>
<ol>
<li>上层来了一个IP层报文，发现<strong>目的IP在当前网段内</strong>（如果不在，不走此流程，下面介绍）、查询缓存表找不到对应的MAC地址（如果查询到也就没有后续流程），也就无法为报文封装链路层header，无法让交换机知道应当发往何方，于是广播一个特殊的链路层报文去查询“拥有此IP的host的MAC地址”，这是一个有限广播，链路层地址为ff:ff:ff:ff:ff:ff<ul>
<li>host与switch是点对点连接的，从功能角度上switch不需要MAC地址，host可以直接发送消息给switch</li>
</ul>
</li>
<li>交换机将报文在当前网段内广播</li>
<li>发现与自身IP地址一致的主机使用点对点通信进行回复</li>
<li>查询结束，写入缓存</li>
</ol>
<p>如果src host与dst host<strong>不在同一个网段</strong>，流程如下，截取一段<br>ref: <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/49337715/answer/115488356">https://www.zhihu.com/question/49337715/answer/115488356</a></p>
<blockquote>
<p>比如说假设从A到B，中间要经过三个路由器：A, R1, R2, R3, B<br>所有设备之间都是以太网。每个设备都有一张路由表，用来区分哪些IP属于本地链路（即可以通过二层协议直达），哪些IP属于非本地链路，以及这些IP地址对应的下一跳路由在哪里。<br><strong>对于A来说，B不在本地链路上，且B的地址对应路由是R1的地址，于是它需要发送一个数据包给R1</strong>，这个数据包：<br>IP源地址：A，IP目的地址：B<br>以太网MAC源地址：A，以太网MAC目的地址：R1<br>由于需要R1的以太网MAC目的地址，而A的路由表中，记录的只有R1的IP地址，因此需要使用ARP协议来解析R1的IP地址对应的MAC地址。如果这个ARP项已经缓存起来了，就会直接使用缓存的结果，否则A会先发起ARP，等到成功解析出MAC地址之后再发送数据包。</p>
</blockquote>
<p>之后，R1也能发现B不在自己本地网段，IP层基于路由算法得到下一跳路由器IP，在链路层报文中填入其MAC地址进行转发：</p>
<ul>
<li>IP源地址：A，IP目的地址：B</li>
<li>以太网MAC源地址：R1，以太网MAC目的地址：R2</li>
</ul>
<p>最终能够转发到B</p>
<p>注：路由器是有MAC地址的</p>
<h3 id="直接广播与有限广播"><a href="#直接广播与有限广播" class="headerlink" title="直接广播与有限广播"></a>直接广播与有限广播</h3><p>直接广播(directed broadcast)<br>（其实不是应该叫有向广播的吗……）<br>有限广播（Limited Broadcasting）</p>
<p>ref: <a target="_blank" rel="noopener" href="https://practice.geeksforgeeks.org/problems/explain-limited-broadcasting-and-directed-broadcasting">https://practice.geeksforgeeks.org/problems/explain-limited-broadcasting-and-directed-broadcasting</a><br>有限广播中，数据传递到相同网络下的所有主机，目的地址为255.255.255.255<br>直接广播用于将消息广播到不同网络中的所有主机，目的地址为IP地址的network part加上全1<br>（IP地址分为network part（网络号）与host part（主机号））</p>
<h3 id="本地网络拓扑"><a href="#本地网络拓扑" class="headerlink" title="本地网络拓扑"></a>本地网络拓扑</h3><p>（一直在以家庭路由器为例思考本地网络拓扑到底是怎样的，总算找到了答案，家庭路由器是星形拓扑，所有host均连接到路由器，路由器除此之外还连接外网）<br>ref: <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20465477/answer/31728857">https://www.zhihu.com/question/20465477/answer/31728857</a></p>
<blockquote>
<p>交换机工作于数据链路层，用来隔离冲突域，连接的所有设备同属于一个广播域（子网），负责子网内部通信。<br>路由器工作于网络层，用来隔离广播域（子网），连接的设备分属不同子网，工作范围是多个子网之间，负责网络与网络之间通信。</p>
<p>家用宽带路由器，其实是交换机和路由器的结合体，有两个网络层接口，一个连接运营商网络，物理上也就是wan口，IP地址由运营商分配。另一个连接家庭网络，没有物理接口，IP地址由自己通过路由器管理界面配置，一般默认是192.168.1.1</p>
<p>那另外几个Lan口干什么用的？这就是交换机接口，和家庭网络接口相连，负责家庭网络内部通信。</p>
</blockquote>
<h3 id="交换机MAC地址学习过程"><a href="#交换机MAC地址学习过程" class="headerlink" title="交换机MAC地址学习过程"></a>交换机MAC地址学习过程</h3><p>解答交换机如何知道与其相连（也许可以是无线连接？）的设备的MAC地址的问题</p>
<p>交换机mac表的获取？ - summer课堂的回答 - 知乎<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/58187639/answer/155994550">https://www.zhihu.com/question/58187639/answer/155994550</a></p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>TODO IP mask的作用</p>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>TODO 作用（提供什么）、过程</p>
<h3 id="Question：为什么要划分子网？"><a href="#Question：为什么要划分子网？" class="headerlink" title="Question：为什么要划分子网？"></a>Question：为什么要划分子网？</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/4QYvwHkIP4UxRibRkdbBSg">https://mp.weixin.qq.com/s/4QYvwHkIP4UxRibRkdbBSg</a></p>
</blockquote>
<ol>
<li>当目的IP&#x3D;自己的IP时，报文不需要离开本机</li>
<li>当目的IP≠自己的IP时，且目的主机的网段 &#x3D; 自己的网段，报文需要离开本机，直接与对方通信</li>
<li>当目的IP≠自己的IP时，且目的主机的网段 ≠ 自己的网段，报文需要离开本机，需要网关中转通信</li>
</ol>
<p>主机如何判断对方是否和自己在一个网段？<strong>只要使用掩码做按位与操作即可</strong>（这就是子网划分的作用）。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="IP-Header"><a href="#IP-Header" class="headerlink" title="IP Header"></a>IP Header</h3><p>共20字节<br>协议版本、报文长度、报文序号、标志和片偏移、TTL、checksum、src ip、dst ip</p>
<ul>
<li>src&#x2F;dst ip: IP协议用于主机到主机的通信，IP地址唯一定位一个主机</li>
<li>TTL: 最多生存的路由跳数</li>
<li>标志：<ul>
<li>DF：是否允许其他路由对分片继续分片（因为可能它的出口链路有更小的MTU）</li>
<li>MF: 1代表后续还有分片，0代表是最后分片</li>
</ul>
</li>
<li>报文序号和片偏移：属于同一个报文的不同分片具有相同的报文序号，片偏移以8字节为单位，记录了分片相对于报文开头的位置</li>
</ul>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>有递归和迭代两种方法，一般用递归，尽管Round Trip数量是一样的，但距离可能不同，比如迭代是北京到上海 + 北京到深圳，而递归是北京到上海 + 上海到深圳<br>（但是递归的话DNS服务器压力会更大吧？）</p>
<p>DNS在服务器间传送时使用TCP，客户端到服务器使用UDP<br>ref: <a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/50993b5f8f0d4a26a2b4fd4c4930d05c?orderByHotValue=1&amp;mutiTagIds=604_644_640_639&amp;page=20&amp;onlyReference=false">https://www.nowcoder.com/questionTerminal/50993b5f8f0d4a26a2b4fd4c4930d05c?orderByHotValue=1&amp;mutiTagIds=604_644_640_639&amp;page=20&amp;onlyReference=false</a></p>
<h3 id="TCP-amp-UDP"><a href="#TCP-amp-UDP" class="headerlink" title="TCP&amp;UDP"></a>TCP&amp;UDP</h3><p>对<code>传输层.md</code>进行补充、总结</p>
<h4 id="TCP-Header"><a href="#TCP-Header" class="headerlink" title="TCP Header"></a>TCP Header</h4><p>共20字节<br>src port 2（字节，后略）, dst port 2, seq num 4, ack num 4, 首部长度 标志位 2, 流量控制窗口 2, checksum 2, 紧急指针 2。</p>
<ul>
<li>src&#x2F;dst port: TCP是进程到进程的通信，同一主机内使用端口号定位进程</li>
<li>首部长度：TCP的头部可以是变长的（一般不变）</li>
<li>流量控制窗口(rwnd Receiver Window）：由接受方计算，值等于缓存大小减已缓存的TCP数据量，发送方已发送未确认的消息大小不应超过这个值</li>
<li>标志位：SYN、ACK、FIN、PSH（立即交付应用层，而不等待缓冲满）、RST、URG<br>以下来自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/h2604396739/article/details/85255092">https://blog.csdn.net/h2604396739/article/details/85255092</a><ul>
<li>RST用于异常关闭连接，FIN属于正常的四次分手</li>
<li>RST不必等缓冲区的包都发出去，直接就丢弃缓存区的包发送RST包。而FIN需要先处理完缓存区的包</li>
<li>接收端收到RST包后，也不必发送ACK包来确认。而FIN需要ACK包确认</li>
</ul>
</li>
</ul>
<p>一般以太网MTU都为1500, 所以在以太网中，往往TCP MSS为1460</p>
<h4 id="UDP-Header"><a href="#UDP-Header" class="headerlink" title="UDP Header"></a>UDP Header</h4><p>共8字节<br>src port, dst port, 消息长度，checksum</p>
<h4 id="技术要点"><a href="#技术要点" class="headerlink" title="技术要点"></a>技术要点</h4><ul>
<li>流量控制：收发方速率平衡</li>
<li>拥塞控制：避免发送太快导致网络拥塞，通过在本地维护rwnd (congestion window)实现，与cwnd相同，单位也是字节（或者说数据量），根据超时或重复ACK判断拥塞。其他重要的点有：cwnd初始指数增长（慢启动阶段，初始值一般两个MSS），到达慢启动阈值ssthresh后线性增长<ul>
<li>快速重传：发送方收到三个冗余确认就应该立即重传尚未收到的报文段，而不必等重传计时器超时。intuition如下：<br>1. 如果发生丢包，那么之后发送的报文都会返回这个相同的ACK，<br>2. 如果消息乱序到达也可能返回冗余ACK<br>收到三个冗余ACK时，协议设计者认为乱序的可能性比丢包可能性要小，认为当前存在丢包，于是立即重传<br>ref: <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21789252">https://www.zhihu.com/question/21789252</a></li>
<li>快速恢复：检测到拥塞后，不重新从最小cwnd+慢启动开始，而是窗口减半+线性增长</li>
</ul>
</li>
<li>pipelining：<br>（这个不太考）<ul>
<li>go back N:<ul>
<li>保持窗口大小个已发送未确认消息</li>
<li>接收方丢弃失序消息，因此ACK代表此前的消息都收到<br>  （感觉不是一个好方法）</li>
</ul>
</li>
<li>selective repeat:<ul>
<li>维护窗口，当窗口第一个元素被确认时，向后移动窗口</li>
<li>窗口内每个元素维护独立的计时器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="TCP端口与UDP端口冲突吗"><a href="#TCP端口与UDP端口冲突吗" class="headerlink" title="TCP端口与UDP端口冲突吗"></a>TCP端口与UDP端口冲突吗</h4><p>不冲突，且二者只是值域相同，数字上没有任何关联关系</p>
<h4 id="TCP如何处理不同的endian"><a href="#TCP如何处理不同的endian" class="headerlink" title="TCP如何处理不同的endian"></a>TCP如何处理不同的endian</h4><p>大端小端的区别是，对于一个字节序列a[i]，它在存储空间（如内存）中从低地址到高地址，是以a[0]…a[n]排列，还是以a[n]…a[0]排列</p>
<p>TCP&#x2F;IP协议族定义网络数据的字节序为大端序[1]，这样发送方与接收方就不必考虑互相的字节序了</p>
<h4 id="TODO-TCP连接断开的处理"><a href="#TODO-TCP连接断开的处理" class="headerlink" title="TODO TCP连接断开的处理"></a>TODO TCP连接断开的处理</h4><p>TOOD 消息来源需要验证<br><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15067225/4334375">https://blog.51cto.com/u_15067225/4334375</a></p>
<ul>
<li>a、b 两个正常连接的对端进程。假如 b 进程没有调用 close 就异常终止，那么发送 FIN 包是内核 OS 代劳</li>
<li>当 TCP 连接建立后，如果某一方断电或断网，如果此时刚好正在发送数据，TCP 数据包发送失败后会重试，重试达到上限时也会断开连接</li>
<li>当 TCP 连接建立后，如果某一方断电或断网，且这条连接没有数据传输时<ul>
<li>如果开启了 KeepAlive 则会在一定心跳检测后断开连接，这个默认检测时间大概2个多小时，比较久</li>
<li>如果未开启 KeepAlive 则连接永远存在</li>
</ul>
</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><ul>
<li>100 表示收到，还需要继续发送消息。<br>使用场景：client仅发送header，server对请求有效性验证，有效返回100，client继续发送，避免了请求无效时，无谓的发送包体的问题</li>
<li>200 成功</li>
<li>300 重定向<ul>
<li>301[2]: 永久重定向。展开：搜索引擎保存定向后的网址</li>
<li>302[2]: 临时重定向。展开：搜索引擎保存定向前的网址</li>
</ul>
</li>
<li>400 客户端导致的问题<ul>
<li>401: 鉴权</li>
<li>404: 访问的资源不存在</li>
<li>405: 不允许使用此Method访问</li>
</ul>
</li>
<li>500 服务端导致的问题</li>
</ul>
<h4 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h4><p>TODO</p>
<h4 id="如何分割TCP中读到的数据流-x2F-分块传输"><a href="#如何分割TCP中读到的数据流-x2F-分块传输" class="headerlink" title="如何分割TCP中读到的数据流&#x2F;分块传输"></a>如何分割TCP中读到的数据流&#x2F;分块传输</h4><p>参考<a href="">分布式基础复习 HW1: Rudy - a small web server</a>，给出简单结论<br>HTTP使用<code>Content-Length</code>与<code>Transfer-Encoding</code>两个Header实现了分隔报文的功能，分别对应定长数据与流式数据（如数据是一边生成一边传输的）<br>扩展到任何协议，都可以使用上述两个机制来在数据流中分割报文，此外，还可以使用特殊字符，但局限性略大一些</p>
<h4 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h4><ol>
<li>不同的HTTP请求可以<strong>复用同一条TCP连接</strong>，但server仍然必须按照请求顺序返回响应（直观理解，否则无法将请求与响应关联；RFC 2616 8.1.2.2[7] 中规定了这一点）。<strong>流程上是串行的：后一个请求必须在前一个响应之后发送</strong></li>
<li>pipeline：<strong>可以在收到上一条请求响应前发送下一条请求</strong>，但与上一条的原因一致，<strong>响应仍然需要串行返回</strong>，无论处于什么原因（请求需要长时间处理、TCP丢包）都会导致后续请求的延迟。（而且这个特性没人用）</li>
</ol>
<p>解释pipeline为什么（相对于串行）会快一些：举个例子，两个请求串行发送，不考虑TCP握手、不考虑消息发送消耗的时间，消耗2RTT+两个请求的处理时间，pipeline发送则消耗1RTT+两个请求的处理时间。pipeline可以看做是多个请求合并。</p>
<p>TODO Tranfer-Encoding、Chunked-Encoding</p>
<p>那么如何提高HTTP请求的并发呢</p>
<ol>
<li>多开几个TCP连接可以避免</li>
<li>浏览器会限制相同域名的TCP连接数，服务端使用多个域名（域名分片）可以解决这一问题</li>
</ol>
<p>多TCP连接也会带来问题，<strong>但pipeline基本上没有多TCP连接要好</strong>：</p>
<ol>
<li>如果业务本来就是串行的（比如依赖返回消息决定下一条的发送消息），那么并不需要pipeline&#x2F;多TCP连接，也没有队头阻塞的问题</li>
<li>TCP连接消耗端口号、内存、FD，握手、DNS</li>
</ol>
<h5 id="我的问题（HTTP1）"><a href="#我的问题（HTTP1）" class="headerlink" title="我的问题（HTTP1）"></a>我的问题（HTTP1）</h5><p>Question: 向一个site建立的多个TCP连接，浏览器会保证向这个site发送的HTTP请求是FIFO的，还是仅在单个TCP级别是FIFO的？<br>答案是仅在TCP连接级别，已经通过ID1212 Network Programming的project做实验证实。</p>
<h5 id="domain-sharding"><a href="#domain-sharding" class="headerlink" title="domain sharding"></a>domain sharding</h5><p>浏览器对每个domain有TCP连接数限制，通过使用不同的domain（或者将不同的domain都解析到同一个server）可以避免这一限制。但引入了域名管理的复杂度</p>
<p>在HTTP2时代已经不存在这个问题了</p>
<ol>
<li>ref: <a target="_blank" rel="noopener" href="https://stackoverflow.com/q/985431/8454039">https://stackoverflow.com/q/985431/8454039</a> 关于使用 *.exapmle.com 实现domain sharding</li>
<li>ref: <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Domain_sharding">https://developer.mozilla.org/zh-CN/docs/Glossary/Domain_sharding</a></li>
</ol>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>建议参考[应用层.md]进行补充</p>
<p>TODO 如果不用 HTTPS 问题是什么 窃听、篡改、冒充<br>核心问题：HTTPS 如何保证安全？何种程度上保证安全？<br>我的理解：<br>TODO 核心逻辑是客户端用服务端公钥加密自己的对称秘钥，细节还要再看下</p>
<blockquote>
<p>服务端可以先将公钥直接发送给客户端，然后客户端自己生成一个随机密钥（TLS里这里交换的其实是预主密钥），然后使用公开的公钥加密这个密钥发送给服务器，因为私钥只有服务器知道，所以只有服务器才能解密这个密钥。这样一来就出现了一个只有客户端和服务器才知道的预主密钥，然后通过这个预主密钥可以生成主密钥，再最终生成工作密钥。</p>
</blockquote>
<p>TLS分为两层：TLS Record Protocol 和 TLS Handshake Protocol[4]</p>
<p>TLS Record Protocol 基于某种可靠的传输协议（如TCP），向上提供两个properties：</p>
<ol>
<li>Private Connection（指对每个连接使用独立的对称秘钥）</li>
<li>Reliable Connection<br>TODO TLS Record Protocol有压缩、数据一致性检查的功能，细节可以参考这个<br>TODO <a target="_blank" rel="noopener" href="https://www.cnblogs.com/flydean/p/ssl-tls-all-in-one.html">https://www.cnblogs.com/flydean/p/ssl-tls-all-in-one.html</a><br>TODO 以及这个 <a target="_blank" rel="noopener" href="https://blog.csdn.net/justinzengTM/article/details/105053478">https://blog.csdn.net/justinzengTM/article/details/105053478</a></li>
</ol>
<p>TLS Record Protocol用于encapsulate多种higher-level protocol，其中的一种（我的理解，看起来也是事实标准）是TLS Handshake Protocol。TLS Handshake Protocol包含三个子协议：Change Cipher Spec Protocol、Alert Protocol与Handshake Protocol，分别用于通知对端随后的消息的加密方式、向对端报告异常信息、交换加密信息。RFC没说，抓包能够观察到消息类型字段还可以是Application Data</p>
<p>[4]给出的握手流程如下</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Client</span>                                               <span class="hljs-type">Server</span><br><br><span class="hljs-type">ClientHello</span>                  <span class="hljs-comment">--------&gt;</span><br>                                                <span class="hljs-type">ServerHello</span><br>                                               <span class="hljs-type">Certificate</span>*<br>                                         <span class="hljs-type">ServerKeyExchange</span>*<br>                                        <span class="hljs-type">CertificateRequest</span>*<br>                             &lt;-<span class="hljs-comment">-------      ServerHelloDone</span><br><span class="hljs-type">Certificate</span>*<br><span class="hljs-type">ClientKeyExchange</span><br><span class="hljs-type">CertificateVerify</span>*<br>[<span class="hljs-type">ChangeCipherSpec</span>]<br><span class="hljs-type">Finished</span>                     <span class="hljs-comment">--------&gt;</span><br>                                         [<span class="hljs-type">ChangeCipherSpec</span>]<br>                             &lt;-<span class="hljs-comment">-------             Finished</span><br><span class="hljs-type">Application</span> <span class="hljs-type">Data</span>             &lt;-<span class="hljs-comment">------&gt;     Application Data</span><br><br>*代表可选<br></code></pre></td></tr></table></figure>

<p>[4] 7.3节简单介绍了握手流程，摘抄如下</p>
<blockquote>
<p>These goals are achieved by the handshake protocol, which can be summarized as follows:</p>
<p>The client sends a client hello message to<br>which the server must respond with a server hello message, or else a<br>fatal error will occur and the connection will fail.  The client<br>hello and server hello are used to establish security enhancement<br>capabilities between client and server.  The client hello and server<br>hello establish the following attributes: Protocol Version, Session<br>ID, Cipher Suite, and Compression Method.  Additionally, two random<br>values are generated and exchanged: ClientHello.random and<br>ServerHello.random.</p>
<p>Following the hello messages, the server will send its certificate, if it is to be authenticated.<br>If the server is authenticated, it may request a certificate from the client, if that is appropriate to the cipher suite selected.<br>Next, the server will send the server hello done message, indicating that<br>the hello-message phase of the handshake is complete.  The server<br>will then wait for a client response.  If the server has sent a<br>certificate request message, the client must send the certificate<br>message.  The client key exchange message is now sent, and the<br>content of that message will depend on the public key algorithm<br>selected between the client hello and the server hello.</p>
<p>At this point, a change cipher spec message is sent by the client,<br>and the client copies the pending Cipher Spec into the current Cipher<br>Spec.  The client then immediately sends the finished message under<br>the new algorithms, keys, and secrets.  In response, the server will<br>send its own change cipher spec message, transfer the pending to the<br>current Cipher Spec, and send its finished message under the new<br>Cipher Spec.  At this point, the handshake is complete, and the<br>client and server may begin to exchange application layer data.</p>
</blockquote>
<h5 id="握手消息解读"><a href="#握手消息解读" class="headerlink" title="握手消息解读"></a>握手消息解读</h5><ul>
<li>Client Hello：包括客户端随机数、多种cipher suites</li>
<li>Server Hello：服务端随机数、服务端选择的cipher suite</li>
<li>Certificate：顾名思义，是一个相对大的消息，百度的cert有3767KB</li>
<li>Server Key Exchange：似乎是用于对称秘钥协商，想了解细节的话参考[4] [5]</li>
<li>Server Hello Done：用于标记Server已经发完它想要发送的所有信息，Server阻塞直到收到client信息</li>
<li>Client Key Exchange：大概也是对称秘钥协商，同Server Key Exchange</li>
<li>Change Cipher Spec：通知对方随后的消息以新的加密方式传输，这也是下方抓包将Finished消息解释为Encrypted Handshake Message的原因</li>
</ul>
<h5 id="Cipher-Suite解读"><a href="#Cipher-Suite解读" class="headerlink" title="Cipher Suite解读"></a>Cipher Suite解读</h5><p>图源[6]<br><img src="https://img-blog.csdnimg.cn/20210301235624614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FydEFuZExpZmU=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" lazyload></p>
<h5 id="HTTPS握手抓包"><a href="#HTTPS握手抓包" class="headerlink" title="HTTPS握手抓包"></a>HTTPS握手抓包</h5><p>执行<code>curl -v https://www.baidu.com</code></p>
<p><img src="https://raw.githubusercontent.com/vicety/Images/master/images20220330182912.png" srcset="/img/loading.gif" lazyload></p>
<p>可以发现在传输Application Data之前，经历如下步骤</p>
<ol>
<li>[TCP] 三次握手</li>
<li>[TLS client -&gt; server] Client Hello</li>
<li>[TLS server -&gt; client] Server Hello, Certificate, Server Key Exchange, Server Hello Done</li>
<li>[TLS client -&gt; server] Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message</li>
<li>[TLS server -&gt; client] Change Cipher Spec, Encrypted Handshake Message</li>
<li>[TLS client -&gt; server] Applicaiton Data</li>
<li>…</li>
<li>[TCP] 四次挥手</li>
</ol>
<p>可以看出，相比于RFC[4]给出的流程，这里的流程如下，上方的Encrypted Handshake Message指的就是下方的Finished：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Client</span>                                               <span class="hljs-type">Server</span><br><br><span class="hljs-type">ClientHello</span>                  <span class="hljs-comment">--------&gt;</span><br>                                                <span class="hljs-type">ServerHello</span><br>                                               <span class="hljs-type">Certificate</span>*<br>                                         <span class="hljs-type">ServerKeyExchange</span>*<br>                             &lt;-<span class="hljs-comment">-------      ServerHelloDone</span><br><span class="hljs-type">ClientKeyExchange</span><br>[<span class="hljs-type">ChangeCipherSpec</span>]<br><span class="hljs-type">Finished</span>                     <span class="hljs-comment">--------&gt;</span><br>                                         [<span class="hljs-type">ChangeCipherSpec</span>]<br>                             &lt;-<span class="hljs-comment">-------             Finished</span><br><span class="hljs-type">Application</span> <span class="hljs-type">Data</span>             &lt;-<span class="hljs-comment">------&gt;     Application Data</span><br><br>*代表可选<br></code></pre></td></tr></table></figure>

<h5 id="其他发现"><a href="#其他发现" class="headerlink" title="其他发现"></a>其他发现</h5><ol>
<li>在Server端消息No.73-75观察到，其Seq一直增长而Ack不变，即Server Hello, Certificate, Server Key Exchange, Server Hello Done实际上只是逻辑上的分割，发送时是连续的字节流</li>
<li>如请求No.73 Length&#x3D;1514，实际上是链路层14，IP Header 20，TCP Header 20，实际上的TCP报文长度是1460。链路层src mac 6字节, dst mac 6字节, 类型IPV4 2字节</li>
<li>TCP segment of a reassembled PDU的意思是wireshard认为这个分片可能是TCP上层协议某条消息的一部分，举例如请求No.74，消息长度1514，显然是其中的一个分片（实际上No.73也是这个情况，只不过wireshark从中找到了完整的client hello消息，就没有标记TCP segment of a reassembled PDU）</li>
</ol>
<h5 id="SSL、TLS与HTTPS的关系"><a href="#SSL、TLS与HTTPS的关系" class="headerlink" title="SSL、TLS与HTTPS的关系"></a>SSL、TLS与HTTPS的关系</h5><p>TLS是比SSL更新的一个协议版本，<strong>TLS&#x2F;SSL是位于传输层与应用层之间的协议，HTTPS可以看做HTTP over SSL&#x2F;TLS</strong>（事实上通过wireshark抓包也可以看到其对于某个报文TLS层的描述：”TLSv1.2 Record Layer: Application Data Protocol: <strong>http-over-tls</strong>“）。可以看出，SSL&#x2F;TLS并不与HTTP绑定<br>[Can SSL be used to encrypt non-HTTP data? [closed]](<a target="_blank" rel="noopener" href="https://security.stackexchange.com/questions/154335/can-ssl-be-used-to-encrypt-non-http-data">https://security.stackexchange.com/questions/154335/can-ssl-be-used-to-encrypt-non-http-data</a></p>
<h4 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h4><p>TODO ref在哪里</p>
<p>相对于HTTP1.1多连接，HTTP2</p>
<ol>
<li>使用单个TCP连接避免了浏览器连接数限制，以及其他多连接造成的限制（握手、慢启动、DNS）</li>
<li>使用单个TCP连接避免了HTTP的队头阻塞（无论是串行发送接收，还是pipeline都有这个问题）。队头阻塞即少量请求在服务端需要大量时间处理，这些请求很快将浏览器允许的所有请求数阻塞，导致后续请求无法被处理。此时HTTP2可以看做解除了连接数限制</li>
<li>一些HTTP2的特性：头部压缩、stream优先级、Server Push</li>
</ol>
<p>可以发现业务方并不要求请求被FIFO处理，HTTP1要求FIFO是因为需要将响应与请求关联，HTTP2在帧中会标记属于哪个stream，解决了此问题，但是大部分HTTP2在下层使用TCP连接，而TCP连接仍然是FIFO的，如果TCP发生丢包，依然会产生类似HTTP1队头阻塞的问题（称为TCP的队头阻塞），<strong>这一方面仍然不如多TCP连接的实现</strong>。</p>
<p>总结：<strong>HTTP2通过多路复用替代了HTTP1中使用多TCP连接避免队头阻塞</strong>，同时增加了头部压缩、stream优先级、Server Push等特性，<strong>但仍然存在TCP层面的队头阻塞问题</strong>。</p>
<h5 id="HTTP2疑问与Tips"><a href="#HTTP2疑问与Tips" class="headerlink" title="HTTP2疑问与Tips"></a>HTTP2疑问与Tips</h5><ul>
<li>只用一个TCP连接的话，服务端如果也只用单个线程来serve的话肯定太愚蠢了吧？是否有证据证明服务端回根据stream开线程分别处理呢？<br><strong>服务端是会进行demultiplexing的</strong>。用ID1212 Network Programming Porject的代码，将服务端处理时间设为无限大，每进入一次处理函数，某个变量自增，打印此变量与go routine id，可以发现400个请求分别打印了250次，说明HTTP2有解复用的逻辑，并不意味着服务端只能单线程处理，并且250似乎是客户端或服务端的concurrent stream limit</li>
<li>HTTP2不严格要求必须使用TLS</li>
</ul>
<h4 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h4><p>基于UDP<br>TODO 如何看待 HTTP&#x2F;3 ？ - 车小胖的回答 - 知乎 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/302412059/answer/533223530">https://www.zhihu.com/question/302412059/answer/533223530</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.csc.kth.se/utbildning/kth/kurser/DD2490/ipro1-10/homeworks/homework_4b_alignment.html#:~:text=big%20endian%20byte%20order">Data Representation: Byte order and alignment</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904097733165069">前端面试：httpcode 301和302的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">List of HTTP status codes</a></li>
<li><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc4346#section-7.4.3">RFC 4346</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@ethicalevil/tls-handshake-protocol-overview-a39e8eee2cf5">TLS v1.2 handshake overview</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/ArtAndLife/article/details/114240424">HTTPS（二）：TLS&#x2F;SSL四次握手及wireshark抓包分析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.1">RFC 2618 8.Connections</a></li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%8A%80%E6%9C%AF/" class="category-chain-item">技术</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%8A%A0%E5%AF%86/">#加密</a>
      
        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">#计算机网络</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>重学计算机网络</div>
      <div>https://vicety.github.io/2022/03/03/重学计算机网络/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>vicety</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年3月3日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/21/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" title="操作系统-内存管理">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统-内存管理</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/02/27/%E9%87%8D%E5%AD%A6Java/" title="重学Java">
                        <span class="hidden-mobile">重学Java</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"p7Skzx1UifgNosmr5ms2nILv-gzGzoHsz","appKey":"W73NSV1s3dRPtfceJDBsX5uP","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/leancloud.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
