

<!DOCTYPE html>
<html lang="zh-cn" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/vicety/Images@master/images/momiji-ico.ico">
  <link rel="icon" href="https://cdn.jsdelivr.net/gh/vicety/Images@master/images/momiji-ico.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="vicety">
  <meta name="keywords" content="">
  
    <meta name="description" content="pid&#x3D;99230581 [toc] 本文主要基于源码介绍select&#x2F;poll&#x2F;epoll技术（实际上并没有poll） 回顾socket编程推荐阅读[1]服务端 socket bind listen accept | read&#x2F;write客户端 soccket connect | read&#x2F;write listen时创建半连接、全连接队列，半连接">
<meta property="og:type" content="article">
<meta property="og:title" content="select poll epoll 源码阅读">
<meta property="og:url" content="https://vicety.github.io/2022/08/18/select-poll-epoll/index.html">
<meta property="og:site_name" content="vicety的博客">
<meta property="og:description" content="pid&#x3D;99230581 [toc] 本文主要基于源码介绍select&#x2F;poll&#x2F;epoll技术（实际上并没有poll） 回顾socket编程推荐阅读[1]服务端 socket bind listen accept | read&#x2F;write客户端 soccket connect | read&#x2F;write listen时创建半连接、全连接队列，半连接">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2846604-91b9ed7c6b066f24.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp">
<meta property="og:image" content="https://raw.githubusercontent.com/vicety/Images/master/images201012122157494693.png">
<meta property="og:image" content="https://raw.githubusercontent.com/vicety/Images/master/images1771657-20200402205610896-733975945.png">
<meta property="og:image" content="https://raw.githubusercontent.com/vicety/Images/master/images1771657-20200402205717703-646415732%20(1).png">
<meta property="og:image" content="https://raw.githubusercontent.com/vicety/Images/master/images1771657-20200402205650773-1956018427.png">
<meta property="og:image" content="https://raw.githubusercontent.com/vicety/Images/master/images2021-12-31-12-44-05.png">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-5ce040484bbe61df5b484730c4cf56cd_1440w.jpg">
<meta property="article:published_time" content="2022-08-18T01:55:00.000Z">
<meta property="article:modified_time" content="2022-08-31T20:57:29.487Z">
<meta property="article:author" content="vicety">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="源码阅读">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/2846604-91b9ed7c6b066f24.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp">
  
  
  
  <title>select poll epoll 源码阅读 - vicety的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"vicety.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 90vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>vicety的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Startseite
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archiv
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Kategorien
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Schlagwörter
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                Über
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://raw.githubusercontent.com/vicety/Images/master/images99230581_p0.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="select poll epoll 源码阅读"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-08-18 03:55" pubdate>
          2022年8月18日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          36k wörter
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          297 minuten
        
      </span>
    

    
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Inhaltsverzeichnis</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">select poll epoll 源码阅读</h1>
            
            
              <div class="markdown-body">
                
                <p>pid&#x3D;99230581</p>
<p>[toc]</p>
<p>本文主要基于源码介绍select&#x2F;poll&#x2F;epoll技术（实际上并没有poll）</p>
<h3 id="回顾socket编程"><a href="#回顾socket编程" class="headerlink" title="回顾socket编程"></a>回顾socket编程</h3><p>推荐阅读[1]<br>服务端 socket bind listen accept | read&#x2F;write<br>客户端 soccket connect | read&#x2F;write</p>
<p>listen时创建半连接、全连接队列，半连接队列对应SYN_RCVD状态的连接，全连接队列对应ESTABLISHED状态的队列</p>
<p>推荐阅读：使用scapy做SYN Flood实验[2]</p>
<p>图片ref: <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3c7a0771b67e">https://www.jianshu.com/p/3c7a0771b67e</a><br><img src="https://upload-images.jianshu.io/upload_images/2846604-91b9ed7c6b066f24.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" srcset="/img/loading.gif" lazyload alt="https://www.jianshu.com/p/3c7a0771b67e"></p>
<p>客户端（一般是客户端先关闭） close<br>服务端 read(return 0) close</p>
<p><img src="https://raw.githubusercontent.com/vicety/Images/master/images201012122157494693.png" srcset="/img/loading.gif" lazyload></p>
<p>TODO</p>
<ol>
<li>为什么一般不多线程读写单个socket，怎么理解<br>socket套接字在多线程发送数据时要加锁吗？ - 陈硕的回答 - 知乎<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/56899596/answer/150926723">https://www.zhihu.com/question/56899596/answer/150926723</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34357887/article/details/93720482">https://blog.csdn.net/weixin_34357887/article/details/93720482</a></li>
</ol>
<h4 id="参考文章（回顾socket编程）"><a href="#参考文章（回顾socket编程）" class="headerlink" title="参考文章（回顾socket编程）"></a>参考文章（回顾socket编程）</h4><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html">Linux Socket编程（不限Linux）</a></li>
<li><a target="_blank" rel="noopener" href="https://cjting.me/2019/08/28/tcp-queue/#%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97syn-queue%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97accept-queue">从一次 Connection Reset 说起，TCP 半连接队列与全连接队列</a></li>
</ol>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="select基本使用"><a href="#select基本使用" class="headerlink" title="select基本使用"></a>select基本使用</h3><p>下面是select的使用例子[5]，为避免每次都打开网页，摘录一部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">fd_set rset; <span class="hljs-comment">//创建一个描述符集rset  </span><br>FD_ZERO(&amp;rset); <span class="hljs-comment">//对描述符集rset清零  </span><br>FD_SET(<span class="hljs-number">0</span>, &amp;rset); <span class="hljs-comment">//将描述符0加入到描述符集rset中  </span><br>FD_SET(<span class="hljs-number">4</span>, &amp;rset); <span class="hljs-comment">//将描述符4加入到描述符集rset中  </span><br>FD_SET(<span class="hljs-number">5</span>, &amp;rset); <span class="hljs-comment">//将描述符5加入到描述符集rset中  </span><br><br><span class="hljs-comment">// 这里没用上select的返回值</span><br><span class="hljs-keyword">if</span>(select(<span class="hljs-number">5</span>+<span class="hljs-number">1</span>, &amp;rset, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>) &gt; <span class="hljs-number">0</span>)  <br>&#123;  <br>    <span class="hljs-comment">// 例子有点挫，实际上这里应该是一个循环</span><br>    <span class="hljs-keyword">if</span>(FD_ISSET(<span class="hljs-number">0</span>, &amp;rset))  <br>        <span class="hljs-comment">//描述符0可读及相应的处理代码  </span><br>        <br>    <span class="hljs-keyword">if</span>(FD_ISSET(<span class="hljs-number">4</span>, &amp;rset))  <br>        <span class="hljs-comment">//描述符4可读及相应的处理代码  </span><br><br>    <span class="hljs-keyword">if</span>(FD_ISSET(<span class="hljs-number">5</span>, &amp;rset))  <br>        <span class="hljs-comment">//描述符5可读及相应的处理代码  </span><br>&#125;  <br></code></pre></td></tr></table></figure>

<h3 id="源码阅读"><a href="#源码阅读" class="headerlink" title="源码阅读"></a>源码阅读</h3><h4 id="select主要逻辑"><a href="#select主要逻辑" class="headerlink" title="select主要逻辑"></a>select主要逻辑</h4><p>2.6.39内核源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE5(select, <span class="hljs-type">int</span>, n, fd_set __user *, inp, fd_set __user *, outp,<br>		fd_set __user *, <span class="hljs-built_in">exp</span>, <span class="hljs-keyword">struct</span> timeval __user *, tvp) <br>    <span class="hljs-comment">// 不看 tvp &gt; 0 有timeout的</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">end_time</span>, *<span class="hljs-title">to</span> =</span> <span class="hljs-literal">NULL</span>;<br>    ret = core_sys_select(n, inp, outp, <span class="hljs-built_in">exp</span>, to);<br>        <span class="hljs-type">long</span> stack_fds[SELECT_STACK_ALLOC/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>)]; <span class="hljs-comment">// SELECT_STACK_ALLOC = 256</span><br>        bits = stack_fds;<br>        fd_set_bits fds;<br>        fds.in      = bits;<br>        fds.out     = bits +   size;<br>        fds.ex      = bits + <span class="hljs-number">2</span>*size;<br>        fds.res_in  = bits + <span class="hljs-number">3</span>*size;<br>        fds.res_out = bits + <span class="hljs-number">4</span>*size;<br>        fds.res_ex  = bits + <span class="hljs-number">5</span>*size;<br><br>        <span class="hljs-keyword">if</span> ((ret = get_fd_set(n, inp, fds.in)) ||<br>	    (ret = get_fd_set(n, outp, fds.out)) ||<br>	    (ret = get_fd_set(n, <span class="hljs-built_in">exp</span>, fds.ex)))<br>            <span class="hljs-comment">// get_fd_set(unsigned long nr, void __user *ufdset, unsigned long *fdset)</span><br>                nr = FDS_BYTES(nr);<br>                <span class="hljs-keyword">if</span> (ufdset)<br>                    <span class="hljs-comment">// to from n</span><br>                    <span class="hljs-keyword">return</span> copy_from_user(fdset, ufdset, nr) ? -EFAULT : <span class="hljs-number">0</span>; <span class="hljs-comment">// 这就是为什么说select每次都涉及拷贝fdset</span><br>		    <span class="hljs-keyword">goto</span> out;<br>        zero_fd_set(n, fds.res_in);<br>        zero_fd_set(n, fds.res_out);<br>        zero_fd_set(n, fds.res_ex);<br><br>        <span class="hljs-comment">// do select也可以看下方分析</span><br>        ret = do_select(n, &amp;fds, end_time); <span class="hljs-comment">// n fds NULL</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_wqueues</span> <span class="hljs-title">table</span>;</span><br>            retval = max_select_fd(n, fds);<br>            n = retval;<br>            poll_initwait(&amp;table); <span class="hljs-comment">// table就是下方的pwq，类型是 poll_wqueues</span><br>                init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait);<br>                    pt-&gt;qproc = qproc;  <span class="hljs-comment">// event_poll 会调用这里设置的 qproc，即 __pollwait</span><br>                    pt-&gt;key   = ~<span class="hljs-number">0UL</span>; <span class="hljs-comment">/* all events enabled */</span><br>                pwq-&gt;polling_task = current; <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 在wait中加入了current，我的理解是这里关联了&quot;要唤醒谁&quot;的信息</span><br>                <span class="hljs-comment">// current 存的是当前进程 ref: https://stackoverflow.com/questions/12434651/what-is-the-current-in-linux-kernel-source</span><br>            wait = &amp;table.pt; <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 注意这个wait</span><br>            retval = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (;;)<br>                <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *rinp, *routp, *rexp, *inp, *outp, *<span class="hljs-built_in">exp</span>;<br>                inp = fds-&gt;in; outp = fds-&gt;out; <span class="hljs-built_in">exp</span> = fds-&gt;ex;<br>		        rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;<br>                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; ++rinp, ++routp, ++rexp)<br>                    in = *inp++; out = *outp++; ex = *<span class="hljs-built_in">exp</span>++;<br>			        all_bits = in | out | ex;<br>                    <span class="hljs-keyword">if</span> (all_bits == <span class="hljs-number">0</span>) &#123;<br>                        i += __NFDBITS; <span class="hljs-comment">// (8 * sizeof(unsigned long))</span><br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <br>                    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; __NFDBITS; ++j, ++i, bit &lt;&lt;= <span class="hljs-number">1</span>)<br>                        <span class="hljs-type">int</span> fput_needed;<br>                        <span class="hljs-keyword">if</span> (i &gt;= n)<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">if</span> (!(bit &amp; all_bits))<br>                            <span class="hljs-keyword">continue</span>;<br>                        file = fget_light(i, &amp;fput_needed); <span class="hljs-comment">// 从 fd 获得 file struct</span><br>                        f_op = file-&gt;f_op;<br>                        wait_key_set(wait, in, out, bit);<br>						mask = (*f_op-&gt;poll)(file, wait); <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 重点！后续分析见下面的代码块</span><br>                        fput_light(file, fput_needed); <span class="hljs-comment">// 似乎是关闭文件</span><br>                        <span class="hljs-keyword">if</span> ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit))<br>                            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 重要！在这里向用户反馈是哪个fd有事件（通过下标），是什么事件（通过res_in还是res_out、res_ex）</span><br>                            res_in |= bit; <br>                            retval++;<br>                            <span class="hljs-comment">// NOTE：wait=NULL 会使得后续 poll 中的 poll_wait 被跳过，因为已经确定要返回了，但已经传进去的还是生效的</span><br>                            wait = <span class="hljs-literal">NULL</span>; <br>                        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 同理 POLLOUT_SET POLLEX_SET 对应 res_out res_ex</span><br>                    cond_resched() <span class="hljs-comment">// 抢占点，迷惑</span><br>                wait = <span class="hljs-literal">NULL</span>;<br>                <span class="hljs-keyword">if</span> (retval || timed_out || signal_pending(current)) <span class="hljs-comment">// 三种返回条件 有事件、超时、信号（？）</span><br>                    <span class="hljs-keyword">break</span>;<br>                poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE, to, slack) <span class="hljs-comment">// (struct poll_wqueues *pwq, int state, ktime_t *expires, unsigned long slack) </span><br>                    set_current_state(state);<br>                    <span class="hljs-comment">// sleep 直到timeout（或interrupt）</span><br>                    <span class="hljs-comment">// 在epoll一节也有分析，内部（如果没有timeout的话）会调用 schedule 放弃 CPU，这也是为什么要套外层的 for(;;)</span><br>                    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 阻塞点</span><br>                    rc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS); <br>                    __set_current_state(TASK_RUNNING);<br>            <span class="hljs-comment">// NOTE：返回时，清理注册到socket wait_address的entry</span><br>            poll_freewait(&amp;table);<br>        <span class="hljs-comment">// 把内核内存中的fd_set（bitmap）拷贝回用户空间</span><br>        <span class="hljs-keyword">if</span> (set_fd_set(n, inp, fds.res_in) ||<br>	    set_fd_set(n, outp, fds.res_out) ||<br>	    set_fd_set(n, <span class="hljs-built_in">exp</span>, fds.res_ex))<br>		ret = -EFAULT;<br>        <br>        <span class="hljs-keyword">return</span> ret;<br>    ret = poll_select_copy_remaining(&amp;end_time, tvp, <span class="hljs-number">1</span>, ret);<br></code></pre></td></tr></table></figure>

<p>ref[3]<br><img src="https://raw.githubusercontent.com/vicety/Images/master/images1771657-20200402205610896-733975945.png" srcset="/img/loading.gif" lazyload></p>
<p>注意：select中没有清理bitmap的操作，返回的bitmap再次传入前要 FD_ZERO 一下</p>
<h4 id="file侧逻辑"><a href="#file侧逻辑" class="headerlink" title="file侧逻辑"></a>file侧逻辑</h4><p>以网络编程常见的socket场景为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> &#123;</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto_ops</span>	*<span class="hljs-title">ops</span>;</span> <span class="hljs-comment">// protocol specific socket operations</span><br>    <span class="hljs-comment">// [2] socket数据结构中的const struct proto_ops对应的是协议的方法集合。每个协议都会实现不同的方法集，对于IPv4 Internet协议族来说,每种协议都有对应的处理方法，如下。对于udp来说，是通过inet_dgram_ops来定义的，其中注册了inet_recvmsg方法。</span><br>&#125;<br><br><span class="hljs-comment">// \net\ipv4\af_inet.c</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proto_ops</span> <span class="hljs-title">inet_dgram_ops</span> =</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    .bind		   = inet_bind,<br>	.connect	   = inet_dgram_connect,<br>	.socketpair	   = sock_no_socketpair,<br>	.accept		   = sock_no_accept,<br>    .poll		   = udp_poll,<br>	.ioctl		   = inet_ioctl,<br>    .sendmsg	   = inet_sendmsg,<br>	.recvmsg	   = inet_recvmsg,<br>&#125;<br><br><span class="hljs-comment">// TODO：作为扩展可以看下eventfd_poll</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> file_operations socket_file_ops = &#123;<br>    <span class="hljs-comment">// ...</span><br>    .poll =		sock_poll,<br>&#125;<br><br><span class="hljs-comment">// 简化版本：select侧</span><br>do_select<br>    <span class="hljs-keyword">struct</span> poll_wqueues table;<br>    poll_initwait(&amp;table);<br>        init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait);<br>            pt-&gt;qproc = qproc; <span class="hljs-comment">// 在下面的wait中注册__pollwait函数</span><br>    wait = &amp;table.pt;<br>    <span class="hljs-keyword">for</span> ;;<br>        <span class="hljs-keyword">for</span> fd<br>            mask = (*f_op-&gt;poll)(file, wait); <span class="hljs-comment">// 调用 fd 实现的 file_operations 接口的 poll 方法</span><br>                udp_poll<br>                    <span class="hljs-title function_">poll_wait</span><span class="hljs-params">(filp, wait_address, p)</span>; <span class="hljs-comment">// do_select 中初始化的 poll_table* wait 一路传到这里（参数 p），wait 中</span><br>                        p-&gt;qproc(filp, wait_address, p); <span class="hljs-comment">// 调用到了上面几行注册的 __pollwait</span><br>                            __pollwait<br>                                <span class="hljs-title function_">if</span> <span class="hljs-params">(p &amp;&amp; wait_address)</span><br>                                    <span class="hljs-keyword">struct</span> poll_table_entry *entry = poll_get_entry(pwq); <span class="hljs-comment">// 获得一个空的entry</span><br>                                    init_waitqueue_func_entry(&amp;entry-&gt;wait, pollwake); <span class="hljs-comment">// 向entry.wait注册pollwake函数</span><br>                                    add_wait_queue(wait_address, &amp;entry-&gt;wait); <span class="hljs-comment">// entry的wait实际上是个list</span><br>        <span class="hljs-comment">// 如果任何fd mask有事件，break</span><br>        <span class="hljs-comment">// 否则睡觉</span><br>        poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE, to, slack))<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 根据mask，将inp/oup/exp的bitmap的fd对应位置置位，稍后拷贝回用户空间</span><br><br><span class="hljs-comment">// 简化版本：唤醒侧</span><br>udp_rcv<br>    sk = __udp4_lib_lookup_skb(skb, uh-&gt;source, uh-&gt;dest, udptable); <span class="hljs-comment">// 根据报文找对应socket</span><br>    udp_queue_rcv_skb(sk, skb);<br>        ip_queue_rcv_skb <span class="hljs-comment">// Queue an skb into sock receive queue</span><br>            sock_queue_rcv_skb<br>                sk-&gt;sk_data_ready(sk, skb_len); <span class="hljs-comment">// NOTE：走到上面的 sock_def_readable</span><br>                    <span class="hljs-comment">// socket初始化时将sk_data_ready赋值为sock_def_readable函数，下面跟进此函数</span><br></code></pre></td></tr></table></figure>

<h4 id="select-callback分析"><a href="#select-callback分析" class="headerlink" title="select callback分析"></a>select callback分析</h4><p>从do_select出发一路追踪callback的执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 完整版本</span><br>do_select<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_wqueues</span> <span class="hljs-title">table</span>;</span><br>	poll_table *wait;<br>    poll_initwait(&amp;table);<br>        <span class="hljs-comment">// table-&gt;pt = qproc</span><br>        <span class="hljs-comment">// pwq-&gt;polling_task = current;</span><br>    wait = &amp;table.pt;<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 这里省略了，还套了一层for，遍历0到最大fd</span><br>    mask = (*f_op-&gt;poll)(file, wait); <span class="hljs-comment">// file struct 下有 f_op 就是 file_operations 接口的实现</span><br>        <span class="hljs-comment">// 等价于调用 sock_poll</span><br>        sock_poll<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> *<span class="hljs-title">sock</span>;</span><br>            sock = file-&gt;private_data; <span class="hljs-comment">// 看起来c语言用void*管理子类特有数据？</span><br>            <span class="hljs-comment">// ops 应该是对应 socket_file_ops，返回mask</span><br>            <span class="hljs-keyword">return</span> sock-&gt;ops-&gt;poll(file, sock, wait);<br>                udp_poll(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-keyword">struct</span> socket *sock, poll_table *wait)<br>                    <span class="hljs-comment">// 返回 mask，有简化</span><br>                    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 重要：socket_poll_wait的逻辑是</span><br>                        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 1. 如果有注册 poll_table* wait 那么注册 pollwake 在收到报文后会有回调去调用 pollwake 唤醒 select 重新调用datagram_poll </span><br>                        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 2. 检查skb队列是否为空，根据结果向select函数返回mask</span><br>                    <span class="hljs-keyword">return</span> datagram_poll(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-keyword">struct</span> socket *sock, poll_table *wait) <span class="hljs-comment">// net/core/datagram.c</span><br>                        <span class="hljs-keyword">struct</span> sock *sk = sock-&gt;sk;<br>                        sock_poll_wait(file, sk_sleep(sk), wait); <span class="hljs-comment">// include/net/sock.h</span><br>                            <span class="hljs-comment">// 看一眼sk_sleep</span><br>                            sk_sleep<br>                                <span class="hljs-keyword">return</span> &amp;<span class="hljs-title function_">rcu_dereference_raw</span><span class="hljs-params">(sk-&gt;sk_wq)</span>-&gt;wait; <span class="hljs-comment">// // 类型 wait_queue_head_t</span><br><br>                            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 注意 sk-&gt;sk_wq-&gt;wait 是socket的等待队列，也是下方的wait_address</span><br>                            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 下方的flip就是上方的file，就是socket文件</span><br>                            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> p就是上面的 wait，从select构造后一路传下来</span><br>                            poll_wait(filp, wait_address, p);<br>                                <span class="hljs-comment">// NOTE：如果 wait 有效（说明select目前还没有发现事件，可能是会睡眠的），向我们维护的、但是select了解的容器 </span><br>                                <span class="hljs-keyword">if</span> (p &amp;&amp; wait_address)<br>                                    p-&gt;qproc(filp, wait_address, p);<br>                                        <span class="hljs-comment">// 假设是 select 的场景</span><br>                                        __pollwait(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">wait_queue_head_t</span> *wait_address, poll_table *p)<br>                                            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_wqueues</span> *<span class="hljs-title">pwq</span> =</span> container_of(p, <span class="hljs-keyword">struct</span> poll_wqueues, pt); <span class="hljs-comment">// 找到外层包围的 poll_wqueue，p在其中的字段名为pt</span><br>                                            <span class="hljs-comment">// NOTE：从数组中获得下一个位置，或者说申请一个 poll_table_entry</span><br>                                            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_entry</span> *<span class="hljs-title">entry</span> =</span> poll_get_entry(pwq); <br>                                                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_page</span> *<span class="hljs-title">table</span> =</span> p-&gt;table; <span class="hljs-comment">// </span><br>                                                <span class="hljs-keyword">if</span> (p-&gt;inline_index &lt; N_INLINE_POLL_ENTRIES)<br>                                                    <span class="hljs-keyword">return</span> p-&gt;inline_entries + p-&gt;inline_index++;<br>                                            get_file(filp); <span class="hljs-comment">// get_file的作用是原子的增加f_count，也就是该文件的引用计数（在close的时候会减这个值）。 ref: https://www.cnblogs.com/lit10050528/p/6206235.html</span><br>                                            entry-&gt;filp = filp;<br>                                            <span class="hljs-comment">// NOTE：将来从wait_address中将注册的entry清理时需要引用wait_address</span><br>                                            entry-&gt;wait_address = wait_address; <br>                                            entry-&gt;key = p-&gt;key;<br>                                            init_waitqueue_func_entry(&amp;entry-&gt;wait, pollwake); <span class="hljs-comment">// entry-&gt;wait 是 wait_queue_t 类型</span><br>                                                q-&gt;func = func; <span class="hljs-comment">// q 是第一个参数</span><br>                                                    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 下面尝试跟进pollwake，但是太深了不看了</span><br>                                                    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 上游是 sk_data_ready -&gt; wake_up_interruptible_sync_poll</span><br>                                                    pollwake(<span class="hljs-type">wait_queue_t</span> *wait, <span class="hljs-type">unsigned</span> mode, <span class="hljs-type">int</span> sync, <span class="hljs-type">void</span> *key)<br>                                                        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_entry</span> <span class="hljs-title">entry</span> =</span> container_of(wait, <span class="hljs-keyword">struct</span> poll_table_entry, wait);<br>                                                        __pollwake(wait, mode, sync, key);<br>                                                            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 注意，这里的entry拿到的内容在下面 entry-&gt;wait.private = pwq</span><br>                                                            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> pwq就是调用select是创建的table，其polling_task 存了 current，也就是select调用方进程</span><br>                                                            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_wqueues</span> *<span class="hljs-title">pwq</span> =</span> wait-&gt;private; <span class="hljs-comment">// wait是wait_queue_t类型</span><br>                                                            DECLARE_WAITQUEUE(dummy_wait, pwq-&gt;polling_task); <br>                                                            <span class="hljs-comment">// NOTE：展开后</span><br>                                                            <span class="hljs-comment">// wait_queue_t dummy_wait = __WAITQUEUE_INITIALIZER(dummy_wait, pwq-&gt;polling_task)</span><br>                                                            <span class="hljs-comment">// #define __WAITQUEUE_INITIALIZER(name, tsk) &#123;				\</span><br><span class="hljs-comment">                                                            //     .private	= tsk,						\</span><br><span class="hljs-comment">                                                            //     .func		= default_wake_function,			\</span><br><span class="hljs-comment">                                                            //     .task_list	= &#123; NULL, NULL &#125; &#125;</span><br>                                                            default_wake_function(&amp;dummy_wait, mode, sync, key); <span class="hljs-comment">// kernel/sched.c</span><br>                                                                <span class="hljs-comment">// try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)</span><br>                                                                <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 这里的curr-&gt;private拿到了之前在pwq中存放的current</span><br>                                                                <span class="hljs-comment">// 第一个参数是 task_struct</span><br>                                                                try_to_wake_up(curr-&gt;private, mode, wake_flags); <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 太深了不看了</span><br>                                            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 重要</span><br>                                            entry-&gt;wait.private = pwq;<br>                                            <span class="hljs-comment">// TODO：其实还存在唤醒几个的问题，entry-&gt;wait可能有多个wait_address</span><br><br>                                            <span class="hljs-comment">// 把entry-&gt;wait添加到wait_address中，即将pollwake函数包装为entry，添加到socket维护的等待队列中</span><br>                                            <span class="hljs-comment">// NOTE：重点！将后者加入前者 前者类型是 wait_queue_head_t 后者是 wait_queue_t</span><br>                                            add_wait_queue(wait_address, &amp;entry-&gt;wait); <br>                                            <span class="hljs-comment">// void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)</span><br>                                                <span class="hljs-comment">// 把entry添加到head的头部</span><br>                                                __add_wait_queue(wq_head, wq_entry); <span class="hljs-comment">// __add_wait_queue(wait_queue_head_t *head, wait_queue_t *new)</span><br>                                                    list_add(&amp;new-&gt;task_list, &amp;head-&gt;task_list); <span class="hljs-comment">// list_add(struct list_head *new, struct list_head *head)</span><br>                                            <span class="hljs-comment">// typedef struct __wait_queue_head wait_queue_head_t</span><br><br>                        mask = <span class="hljs-number">0</span>;<br><br>                        <span class="hljs-comment">// POLLIN     There is data to read.</span><br>                        <span class="hljs-comment">// POLLRDNORM Equivalent to POLLIN.</span><br><br>                        <span class="hljs-comment">/* exceptional events? */</span><br>                        <span class="hljs-keyword">if</span> (sk-&gt;sk_err || !skb_queue_empty(&amp;sk-&gt;sk_error_queue))<br>                            mask |= POLLERR;<br>                        <span class="hljs-keyword">if</span> (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN)<br>                            mask |= POLLRDHUP | POLLIN | POLLRDNORM;<br>                        <span class="hljs-keyword">if</span> (sk-&gt;sk_shutdown == SHUTDOWN_MASK)<br>                            mask |= POLLHUP;<br>                        <span class="hljs-comment">/* readable? */</span><br>                        <span class="hljs-keyword">if</span> (!skb_queue_empty(&amp;sk-&gt;sk_receive_queue))<br>                            mask |= POLLIN | POLLRfdw2DNORM; <br>                        <span class="hljs-comment">// ...</span><br>                        <span class="hljs-keyword">if</span> (sock_writeable(sk))<br>                            mask |= POLLOUT | POLLWRNORM | POLLWRBAND;<br>                        <span class="hljs-keyword">return</span> mask;<br></code></pre></td></tr></table></figure>

<p>ref[3]<br><img src="https://raw.githubusercontent.com/vicety/Images/master/images1771657-20200402205717703-646415732%20(1).png" srcset="/img/loading.gif" lazyload></p>
<h4 id="select-callback调用时机"><a href="#select-callback调用时机" class="headerlink" title="select callback调用时机"></a>select callback调用时机</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 看下socket何时唤醒它</span><br>sock_init_data <span class="hljs-comment">// socket初始化</span><br>    sk-&gt;sk_state_change	=	sock_def_wakeup;<br>        wake_up_interruptible_all(&amp;wq-&gt;wait);<br>    sk-&gt;sk_data_ready	=	sock_def_readable;<br>        wq = rcu_dereference(sk-&gt;sk_wq);<br>        wake_up_interruptible_sync_poll(&amp;wq-&gt;wait, POLLIN | POLLPRI | POLLRDNORM | POLLRDBAND); <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 重点</span><br>            <span class="hljs-comment">// #define wake_up_interruptible_sync_poll(x, m) \</span><br><span class="hljs-comment">	        //     __wake_up_sync_key((x), TASK_INTERRUPTIBLE, 1, (void *) (m))</span><br>            __wake_up_sync_key(<span class="hljs-type">wait_queue_head_t</span> *q, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mode, <span class="hljs-type">int</span> nr_exclusive, <span class="hljs-type">void</span> *key)<br>                <span class="hljs-comment">// __wake_up_common(wait_queue_head_t *q, unsigned int mode, int nr_exclusive, int wake_flags, void *key)</span><br>                __wake_up_common(q, mode, nr_exclusive, wake_flags, key); <span class="hljs-comment">// 详细分析可以看 http://abcdxyzk.github.io/blog/2015/06/12/kernel-net-socket-io/</span><br>                    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 遍历socket wait_queue 调用通过 等待队列机制 向 wait_queue 中注册的 callback</span><br>                    list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) <span class="hljs-comment">// q 就是 wait_queue_head_t*</span><br>                        <span class="hljs-comment">// curr类型 wait_queue_t</span><br>                        curr-&gt;func(curr, mode, wake_flags, key) <span class="hljs-comment">// 这个func 就是 pollwake</span><br>        sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);<br>            sock_wake_async(sk-&gt;sk_socket, how, band);<br><br>ip_local_deliver<br>    ip_local_deliver_finish <span class="hljs-comment">// IP层结束</span><br>        udp_rcv<br>            __udp4_lib_rcv<br>                sk = __udp4_lib_lookup_skb(skb, uh-&gt;source, uh-&gt;dest, udptable); <span class="hljs-comment">// 根据报文找对应socket</span><br>                udp_queue_rcv_skb(sk, skb);<br>                    __udp_queue_rcv_skb<br>                        ip_queue_rcv_skb <span class="hljs-comment">// Queue an skb into sock receive queue</span><br>                            sock_queue_rcv_skb<br>                                sk-&gt;sk_data_ready(sk, skb_len); <span class="hljs-comment">// NOTE：走到上面的 sock_def_readable</span><br><span class="hljs-comment">// 寻找 sock_queue_rcv_skb 被调过程中参考了</span><br><span class="hljs-comment">// 1. http://kerneltravel.net/blog/2020/network_ljr10/</span><br><span class="hljs-comment">// 2. [4]</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">wait_queue_head</span> <span class="hljs-title">wait_queue_head_t</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">wait_queue_head</span> &#123;</span><br>	<span class="hljs-type">spinlock_t</span> lock;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">task_list</span>;</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">wait_queue</span> <span class="hljs-title">wait_queue_t</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">wait_queue</span> &#123;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>		flags;<br>	<span class="hljs-type">void</span>			*private;<br>	<span class="hljs-type">wait_queue_func_t</span>	func;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>	<span class="hljs-title">task_list</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>ref[3]<br><img src="https://raw.githubusercontent.com/vicety/Images/master/images1771657-20200402205650773-1956018427.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="如何实现一个支持select的设备"><a href="#如何实现一个支持select的设备" class="headerlink" title="如何实现一个支持select的设备"></a>如何实现一个支持select的设备</h3><p>参考了[3]，其中还有代码实现，实现起来并不止下面这些，但下面的是核心</p>
<ol>
<li>定义一个等待队列头 <code>wait_queue_head_t</code> ，用于收留等待队列任务</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 比如socket中的实现</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket</span> &#123;</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span>		*<span class="hljs-title">sk</span>;</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span> &#123;</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket_wq</span> __<span class="hljs-title">rcu</span>	*<span class="hljs-title">sk_wq</span>;</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">socket_wq</span> &#123;</span><br>	<span class="hljs-type">wait_queue_head_t</span>	wait;<br>	<span class="hljs-comment">// ...</span><br>&#125; ____cacheline_aligned_in_smp;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">wait_queue_head</span> <span class="hljs-title">wait_queue_head_t</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">wait_queue_head</span> &#123;</span><br>	<span class="hljs-type">spinlock_t</span>		lock;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>	<span class="hljs-title">task_list</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>实现fd的接口 <code>file_operations</code> （中的一部分？），可以确定的是poll函数是一定需要实现的，通常命名为 <code>xxx_poll()</code></li>
<li>xxx_poll()函数中<ol>
<li>需要对 <code>poll_wait</code> 进行调用，将select传来的 <code>poll_table* wait</code> 与 第一步中提到的 <code>wait_queue_head_t</code> 传入</li>
<li>该函数的返回值mask需要返回当前fd可读状态之类的信息，比如EPOLLIN&#x2F;EPOLL&#x2F;EPOLLERR等，这个返回值在do_select()函数中会去判断处理</li>
</ol>
</li>
<li>条件满足的时候（比如有数据可读了），通过 <code>wake_up_interruptible</code> 系列API唤醒任务，传入第一步中提到的 <code>wait_queue_head_t</code></li>
</ol>
<h3 id="Select缺陷"><a href="#Select缺陷" class="headerlink" title="Select缺陷"></a>Select缺陷</h3><p>经典八股</p>
<ol>
<li>fd两次拷贝</li>
<li>FD_SETSIZE&#x3D;1024，而文档中提到当fd值超过1024时，FD_SET系列宏的行为是undefined的</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://pubs.opengroup.org/onlinepubs/7908799/xsh/select.html">https://pubs.opengroup.org/onlinepubs/7908799/xsh/select.html</a><br>The behaviour of these macros is undefined if the fd argument is less than 0 or greater than or equal to FD_SETSIZE, or if any of the arguments are expressions with side effects.</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/posix_types.h#L27">https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/posix_types.h#L27</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __FD_SETSIZE	1024</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> fds_bits[__FD_SETSIZE / (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>))];<br>&#125; __kernel_fd_set;<br><span class="hljs-keyword">typedef</span> __kernel_fd_set		fd_set;<br></code></pre></td></tr></table></figure>

<p>通常直接在栈上申请 fd_set，按照上面的类型定义，会有1024的问题，而下方链接的博主尝试在堆上分配时可以超过1024的<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/dog250/article/details/105896693">https://blog.csdn.net/dog250/article/details/105896693</a></p>
<ol start="3">
<li>只知道有事情发生了，仍然需要O(n)遍历，使用 FD_ISSET 去检查是否是这个 FD 有事件</li>
</ol>
<h3 id="Select是ET还是LT？"><a href="#Select是ET还是LT？" class="headerlink" title="Select是ET还是LT？"></a>Select是ET还是LT？</h3><p>根据源码分析中socket实现的poll可知，poll返回的是接受队列是否为空，所以至少对于select常见的socket编程场景下是LT的</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实看上面怎么自己实现一个支持select的设备就够了，select本质就是对监听的每个fd尝试poll，若无消息（暂不可读）则向其注册一个wake函数，其中写了当前进程，若全部file无消息则调用进程睡眠。file内部需要在有变化时主动调用 <code>wake_up_interruptible</code> 之类的函数，并将注册有 wake函数的容器传入，实现解除select的阻塞</p>
<h3 id="参考文章（select）"><a href="#参考文章（select）" class="headerlink" title="参考文章（select）"></a>参考文章（select）</h3><ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/64138532">如果这篇文章说不清epoll的本质，那就过来掐死我吧！ （2）</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/256428917">图解Linux网络包接收过程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LoyenWang/p/12622904.html">【原创】Linux select&#x2F;poll机制原理分析</a></li>
<li>TODO 没看完 但是强推 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008836467">Linux网络 - 数据包的接收过程</a><br>TODO 也强推[4]中最后引用的几篇英文文章</li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b404ac51dc62">Linux网络编程——I&#x2F;O复用之select详解</a></li>
</ol>
<p>TODO 如果多个进程阻塞使用相同的fdset去调用select？</p>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>TODO 可以简单介绍一下</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><h3 id="epoll基本使用"><a href="#epoll基本使用" class="headerlink" title="epoll基本使用"></a>epoll基本使用</h3><p>可运行的例子见[7]，下面摘录网上的另一个例子，出处找不到了……<br>此外例[7]处理了关闭连接，也值得借鉴<br>TODO 上面的例子只有read，听说写socket也可以加入epoll，有空看下 <a target="_blank" rel="noopener" href="https://github.com/abbshr/C10K-web-server/blob/master/event-driven-model/epoll-server.c">https://github.com/abbshr/C10K-web-server/blob/master/event-driven-model/epoll-server.c</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">ev</span>, <span class="hljs-title">event</span>[<span class="hljs-title">MAX_EVENT</span>];</span><br>listenfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 打开 socket 端口复用, 防止测试的时候出现 Address already in use</span><br>result = setsockopt( listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="hljs-keyword">sizeof</span>(on) );<br>result = bind(listenfd, (<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *)&amp;server_addr, <span class="hljs-keyword">sizeof</span> (server_addr));<br>result = make_socket_non_blocking(listenfd);<br>result = listen(listenfd, <span class="hljs-number">200</span>);<br>epfd = epoll_create1(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// NOTE：ev.data中的数据只是为了收到通知后你能得知这个event的一些信息（比如这里我们就能知道是哪个fd上有事件）</span><br>ev.data.fd = listenfd;<br>ev.events = EPOLLIN | EPOLLET <span class="hljs-comment">/* 边缘触发选项。 */</span>;<br><span class="hljs-comment">// 设置epoll的事件</span><br>result = epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev);<br><span class="hljs-type">int</span> wait_count;<br><span class="hljs-keyword">for</span> (;;)<br>    wait_count = epoll_wait(epfd, event, MAX_EVENT, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; wait_count; i++)<br>        <span class="hljs-type">uint32_t</span> events = event[i].events;<br>        <span class="hljs-comment">// 判断epoll是否发生错误</span><br>        <span class="hljs-keyword">if</span> ( events &amp; EPOLLERR || events &amp; EPOLLHUP || (! events &amp; EPOLLIN))<br>            <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (listenfd == event[i].data.fd)<br>            <span class="hljs-comment">// listenfd的事件，有新连接</span><br>            <span class="hljs-keyword">for</span> (;;) <span class="hljs-comment">// 由于采用了边缘触发模式，这里需要使用循环</span><br>                <span class="hljs-type">int</span> accp_fd = accept(listenfd, &amp;in_addr, &amp;in_addr_len);<br>                <span class="hljs-comment">// 获得socket的一些信息，打印</span><br>                __result = getnameinfo(&amp;in_addr, <span class="hljs-keyword">sizeof</span> (in_addr),<br>                                           host_buf, <span class="hljs-keyword">sizeof</span> (host_buf) / <span class="hljs-keyword">sizeof</span> (host_buf[<span class="hljs-number">0</span>]),<br>                                           port_buf, <span class="hljs-keyword">sizeof</span> (port_buf) / <span class="hljs-keyword">sizeof</span> (port_buf[<span class="hljs-number">0</span>]),<br>                                           NI_NUMERICHOST | NI_NUMERICSERV);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;New connection: host = %s, port = %s\n&quot;</span>, host_buf, port_buf);<br>                __result = make_socket_non_blocking(accp_fd);<br>                <span class="hljs-comment">// 由于会拷贝到内核空间，所以可以复用同一个</span><br>                ev.data.fd = accp_fd;<br>                ev.events = EPOLLIN | EPOLLET;<br>                __result = epoll_ctl(epfd, EPOLL_CTL_ADD, accp_fd, &amp;ev);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 文件可读</span><br>            <span class="hljs-comment">// 因为采用边缘触发，所以这里需要使用循环。如果不使用循环，程序并不能完全读取到缓存区里面的数据。</span><br>            <span class="hljs-type">int</span> done = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (;;)<br>                result_len = read(event[i].data.fd, buf, <span class="hljs-keyword">sizeof</span> (buf) / <span class="hljs-keyword">sizeof</span> (buf[<span class="hljs-number">0</span>]));<br>                <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == result_len)<br>                    <span class="hljs-comment">// ref: stackoverflow </span><br>                    <span class="hljs-comment">// EAGAIN is often raised when performing non-blocking I/O. It means &quot;there is no data available right now, try again later&quot;.</span><br>                    <span class="hljs-keyword">if</span> (EAGAIN != errno) <br>                        <span class="hljs-comment">// 出错，break+关闭连接</span><br>                        perror (<span class="hljs-string">&quot;Read data&quot;</span>);<br>                        done = <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (! result_len)<br>                    done = <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                write(STDOUT_FILENO, buf, result_len);<br>            <span class="hljs-keyword">if</span> (done) <br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Closed connection\n&quot;</span>);<br>                close (event[i].data.fd);<br>close (epfd);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;           <br></code></pre></td></tr></table></figure>

<h3 id="epoll源码阅读"><a href="#epoll源码阅读" class="headerlink" title="epoll源码阅读"></a>epoll源码阅读</h3><p>ref[3]<br><img src="https://raw.githubusercontent.com/vicety/Images/master/images2021-12-31-12-44-05.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This structure is stored inside the &quot;private_data&quot; member of the file</span><br><span class="hljs-comment"> * structure and represents the main data structure for the eventpoll</span><br><span class="hljs-comment"> * interface.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> &#123;</span><br>    <span class="hljs-comment">/* Wait queue used by sys_epoll_wait() */</span><br>	<span class="hljs-type">wait_queue_head_t</span> wq;<br>    <span class="hljs-comment">/* Wait queue used by file-&gt;poll() */</span><br>	<span class="hljs-type">wait_queue_head_t</span> poll_wait;<br>    <span class="hljs-comment">/* List of ready file descriptors */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">rdllist</span>;</span><br>    <span class="hljs-comment">/* RB tree root used to store monitored fd structs */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> <span class="hljs-title">rbr</span>;</span><br>    <span class="hljs-comment">/* The user that created the eventpoll descriptor */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span>;</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> *<span class="hljs-title">rb_node</span>;</span> <span class="hljs-comment">// 注意是指针，而下方epitem的是对象，此指针通过container_of可以找到epitem</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> &#123;</span><br>    <span class="hljs-comment">/* RB tree node used to link this structure to the eventpoll RB tree */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> <span class="hljs-title">rbn</span>;</span><br>    <span class="hljs-comment">/* List header used to link this structure to the eventpoll ready list */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">rdllink</span>;</span><br>    <span class="hljs-comment">/* The file descriptor information this item refers to */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_filefd</span> <span class="hljs-title">ffd</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>	    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-comment">/* Number of active wait queue attached to poll operations */</span><br>	<span class="hljs-type">int</span> nwait;<br>    <span class="hljs-comment">/* List containing poll wait queues */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">pwqlist</span>;</span><br>    <span class="hljs-comment">/* The &quot;container&quot; of this item */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span>;</span><br>    <span class="hljs-comment">/* The structure that describe the interested events and the source fd */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event</span>;</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> &#123;</span><br>	__u32 events;<br>	__u64 data;<br>&#125; EPOLL_PACKED;<br><br><span class="hljs-comment">// NOTE：奇怪的是 https://man7.org/linux/man-pages/man2/epoll_wait.2.html 中，以及网上的应用中，是这样定义的</span><br><span class="hljs-comment">// 当然也无所谓，__u64 data看做指针就好</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span>     events;    <span class="hljs-comment">/* Epoll events */</span><br>    <span class="hljs-type">epoll_data_t</span> data;      <span class="hljs-comment">/* User data variable */</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>第一次关注 fs_initcall，介绍可以参考 <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1554770">https://cloud.tencent.com/developer/article/1554770</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">fs_initcall(eventpoll_init);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">si</span>;</span><br>        <span class="hljs-comment">// totalhigh: high zone部分的物理内存大小，在64位系统中由于不存在high zone故位0，32位系统中根据实际情况</span><br>        <span class="hljs-comment">// ref: https://blog.csdn.net/weixin_42730667/article/details/117629859</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> totalhigh;	<span class="hljs-comment">/* Total high memory size */</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> totalram;		<span class="hljs-comment">/* Total usable main memory size */</span><br>	    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> freeram;		<span class="hljs-comment">/* Available memory size */</span><br>        <span class="hljs-comment">// mem_unit: 页面大小</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mem_unit;		<span class="hljs-comment">/* Memory unit size in bytes */</span><br>        <span class="hljs-comment">// ...</span><br>	si_meminfo(&amp;si); <span class="hljs-comment">// 获得系统信息</span><br>    <span class="hljs-comment">// 页表大小4KB，对应12位</span><br>    <span class="hljs-comment">// #define PAGE_SHIFT	12 // arch/x86/include/asm/page_types.h</span><br>    <span class="hljs-comment">// 所以这里的totalram是以页表为单位的？ 迷惑，先按给的注释来吧</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Allows top 4% of lomem to be allocated for epoll watches (per user).</span><br><span class="hljs-comment">	 */</span><br>    max_user_watches = (((si.totalram - si.totalhigh) / <span class="hljs-number">25</span>) &lt;&lt; PAGE_SHIFT) /<br>		EP_ITEM_COST; <span class="hljs-comment">// #define EP_ITEM_COST (sizeof(struct epitem) + sizeof(struct eppoll_entry))</span><br>    <span class="hljs-comment">// ... 其他的用到了再来看，略</span><br></code></pre></td></tr></table></figure>

<h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE1(epoll_create, <span class="hljs-type">int</span>, size)<br>    SYSCALL_DEFINE1(epoll_create1, <span class="hljs-type">int</span>, flags)<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span> =</span> <span class="hljs-literal">NULL</span>;<br>        error = ep_alloc(&amp;ep);<br>            user = get_current_user();<br>            ep = kzalloc(<span class="hljs-keyword">sizeof</span>(*ep), GFP_KERNEL); <span class="hljs-comment">// GFP_KERNEL 是内存分配时的选项</span><br>            init_waitqueue_head(&amp;ep-&gt;wq); <span class="hljs-comment">// wait_queue_head_t 类型，select中也有用到</span><br>	        init_waitqueue_head(&amp;ep-&gt;poll_wait);<br>            INIT_LIST_HEAD(&amp;ep-&gt;rdllist);<br>            <span class="hljs-comment">// #define RB_ROOT	(struct rb_root) &#123; NULL, &#125;</span><br>            ep-&gt;rbr = RB_ROOT;<br>            ep-&gt;ovflist = EP_UNACTIVE_PTR;<br>	        ep-&gt;user = user;<br>            <span class="hljs-comment">// Creates a new file by hooking it on a single inode. This is useful for files</span><br>            <span class="hljs-comment">//  * that do not need to have a full-fledged inode in order to operate correctly.</span><br>            <span class="hljs-comment">//  * All the files created with anon_inode_getfd() will share a single inode,</span><br>            <span class="hljs-comment">// 传入 name、file_opearations、private_data、flags</span><br>            error = anon_inode_getfd(<span class="hljs-string">&quot;[eventpoll]&quot;</span>, &amp;eventpoll_fops, ep,<br>				 O_RDWR | (flags &amp; O_CLOEXEC));<br>            <span class="hljs-keyword">return</span> error; <span class="hljs-comment">// error实际上是fd，无语子</span><br><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> epfd作为一个fd也实现了file_operations，我理解poll对应epoll套epoll的情况，先不看了</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">eventpoll_fops</span> =</span> &#123;<br>	.release	= ep_eventpoll_release,<br>	.poll		= ep_eventpoll_poll,<br>	.llseek		= noop_llseek,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE4(epoll_ctl, <span class="hljs-type">int</span>, epfd, <span class="hljs-type">int</span>, op, <span class="hljs-type">int</span>, fd,<br>		<span class="hljs-keyword">struct</span> epoll_event __user *, event)<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">epds</span>;</span><br>    <span class="hljs-comment">// 如果op是DEL，那么不用将event拷贝到内核空间，这部分略</span><br>    copy_from_user(&amp;epds, event, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> epoll_event))<br>    <br>    file = fget(epfd);<br>    tfile = fget(fd); <span class="hljs-comment">// target file</span><br>    <span class="hljs-comment">// 不能自己监听自己、且epfd应对应一个eventepoll file，后者通过检查file的op来确定</span><br>    <span class="hljs-keyword">if</span> (file == tfile || !is_file_epoll(file))<br>		<span class="hljs-keyword">goto</span> error_tgt_fput;    <br>    ep = file-&gt;private_data; <span class="hljs-comment">// 获得 eventpoll 对象</span><br>    <span class="hljs-comment">// epoll下挂的fd不能成环，如ep1监听ep2 ep2监听ep1，代码略</span><br>    mutex_lock(&amp;ep-&gt;mtx);<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 唯一的一处红黑树查找</span><br>    epi = ep_find(ep, tfile, fd); <span class="hljs-comment">// 在ep的rbt中搜索tfile，(tfile, fd)作为搜索的key （大概，未确认）</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> *<span class="hljs-title">rbp</span>;</span><br>        ep_set_ffd(&amp;ffd, file, fd);<br>            ffd-&gt;file = file;<br>	        ffd-&gt;fd = fd;<br>        <span class="hljs-keyword">for</span> (rbp = ep-&gt;rbr.rb_node; rbp; )<br>            <span class="hljs-comment">// #define	rb_entry(ptr, type, member) container_of(ptr, type, member)</span><br>            <span class="hljs-comment">// include/linux/rbtree.h</span><br>            epi = rb_entry(rbp, <span class="hljs-keyword">struct</span> epitem, rbn); <span class="hljs-comment">// ep的rbr的rb_node指针，通过container_of找到其外围包裹的</span><br>            kcmp = ep_cmp_ffd(&amp;ffd, &amp;epi-&gt;ffd); <span class="hljs-comment">// 先对比file，后对比fd</span><br>            <span class="hljs-keyword">if</span> (kcmp &gt; <span class="hljs-number">0</span>)<br>                rbp = rbp-&gt;rb_right;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (kcmp &lt; <span class="hljs-number">0</span>)<br>                rbp = rbp-&gt;rb_left;<br>            <span class="hljs-keyword">else</span><br>                epir = epi;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 简单的二叉树查找</span><br>    <span class="hljs-keyword">switch</span> (op)<br>        <span class="hljs-keyword">case</span> EPOLL_CTL_ADD:<br>            <span class="hljs-keyword">if</span> (!epi) <span class="hljs-comment">// 如果节点不存在</span><br>                <span class="hljs-comment">// NOTE：添加其他需要唤醒的状态</span><br>                epds.events |= POLLERR | POLLHUP;<br>                <span class="hljs-comment">// 唯一的一处红黑树插入</span><br>                ep_insert(ep, &amp;epds, tfile, fd);<br>        <span class="hljs-keyword">case</span> EPOLL_CTL_DEL:<br>            <span class="hljs-keyword">if</span> (epi)<br>                error = ep_remove(ep, epi);<br>        <span class="hljs-keyword">case</span> EPOLL_CTL_MOD:<br>            <span class="hljs-keyword">if</span> (epi)<br>                epds.events |= POLLERR | POLLHUP;<br>			    error = ep_modify(ep, epi, &amp;epds);<br>    mutex_unlock(&amp;ep-&gt;mtx);<br></code></pre></td></tr></table></figure>

<p>追踪一下 ep_insert</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs c">ep_insert(<span class="hljs-keyword">struct</span> eventpoll *ep, <span class="hljs-keyword">struct</span> epoll_event *event, <span class="hljs-comment">// event是用户传来的 epoll_event（如 EPOLLIN | EPOLLET）</span><br>		     <span class="hljs-keyword">struct</span> file *tfile, <span class="hljs-type">int</span> fd)<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span>;</span><br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 注意epq是一个短时的栈上对象，仅用于调用file的poll，它存了epi和polltable，后者就是 ep_ptable_queue_proc callback的包装</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ep_pqueue</span> <span class="hljs-title">epq</span>;</span><br>        poll_table pt; <span class="hljs-comment">// select中也在用的一个struct</span><br>            <span class="hljs-comment">// include/linux/poll.h</span><br>            <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">poll_table_struct</span> &#123;</span><br>                poll_queue_proc _qproc;<br>                <span class="hljs-type">__poll_t</span> _key;<br>            &#125; poll_table;<br>	    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span>;</span><br>    <span class="hljs-comment">// 不能注册太多watch，限制了内存消耗</span><br>    user_watches = atomic_long_read(&amp;ep-&gt;user-&gt;epoll_watches);<br>    <span class="hljs-keyword">if</span> (unlikely(user_watches &gt;= max_user_watches))<br>		<span class="hljs-keyword">return</span> -ENOSPC;<br>    <br>    epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)<br>    INIT_LIST_HEAD(&amp;epi-&gt;rdllink);<br>	INIT_LIST_HEAD(&amp;epi-&gt;fllink);<br>	INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);<br>    epi-&gt;ep = ep;<br>	ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd); <span class="hljs-comment">// 用于在红黑树中比较</span><br>	epi-&gt;event = *event; <span class="hljs-comment">// 在读ready list返回结果时会再次用到</span><br>	epi-&gt;nwait = <span class="hljs-number">0</span>;<br>	epi-&gt;next = EP_UNACTIVE_PTR;<br><br>    epq.epi = epi;<br>	init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc); <span class="hljs-comment">// 有理由相信这里和之前在select内的逻辑会很像，与select不同，这里的</span><br>        pt-&gt;qproc = qproc;<br>    <br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 调用target file的poll，传入 poll_table</span><br>    revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);<br>        <span class="hljs-comment">// 这里放一下select中 sock-&gt;ops-&gt;poll(file, sock, wait); 的简化版本</span><br>        udp_poll<br>            datagram_poll<br>                <span class="hljs-comment">// 分别是socket文件、socket等待队列、poll_table</span><br>                sock_poll_wait(file, sk_sleep(sk), wait);<br>                    poll_wait(filp, wait_address, p); <br>                        <span class="hljs-keyword">if</span> (p &amp;&amp; wait_address)<br>                            p-&gt;qproc(filp, wait_address, p);<br>                                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                                * This is the callback that is used to add our wait queue to the</span><br><span class="hljs-comment">                                * target file wakeup lists.</span><br><span class="hljs-comment">                                */</span><br>                                ep_ptable_queue_proc(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">wait_queue_head_t</span> *whead, poll_table *pt)<br>                                    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span> =</span> ep_item_from_epqueue(pt); <span class="hljs-comment">// poll_table 找到外部的 ep_pqueue 再访问 eq_queue-&gt;epi:epitem，epitem包含红黑树比较的key、用户传来的epoll选项（EPOLLIN | EPOLLET 等）</span><br>                                        <span class="hljs-keyword">return</span> container_of(p, <span class="hljs-keyword">struct</span> ep_pqueue, pt)-&gt;epi; <br>                                    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eppoll_entry</span> *<span class="hljs-title">pwq</span>;</span><br>                                    <span class="hljs-comment">// 申请 eppoll_entry ，类似于select中的poll_table_entry（？）</span><br>                                    <span class="hljs-keyword">if</span> (epi-&gt;nwait &gt;= <span class="hljs-number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL)))<br>                                        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 向entry中注入 ep_poll_callback</span><br>                                        init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback); <br>                                            q-&gt;func = func;<br>                                        pwq-&gt;whead = whead; <span class="hljs-comment">// whead就是socket的等待队列，EPOLL_CTL_DEL是需要通过它将whead中注册的epi删除</span><br>                                        pwq-&gt;base = epi;<br>                                        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 将新申请的 entry 加入 socket等待队列，wait的类型是 wait_queue_t</span><br>                                        add_wait_queue(whead, &amp;pwq-&gt;wait); <br>                                        <span class="hljs-comment">// 将申请的entry pwq加入epoll_ctl insert是创建的 epitem</span><br>                                        <span class="hljs-comment">// Question: 这一行的意义是什么</span><br>                                        list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist); <span class="hljs-comment">// 将 param1 添加到 param2 的尾部，这里双向链表的头尾是连接起来的</span><br>                                        epi-&gt;nwait++;<br>                                            <span class="hljs-comment">// =================== 跟踪 ep_poll_callback ======================</span><br>                                            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ep_poll_callback 的被调时机是 sk_data_ready -&gt; wake_up_interruptible_sync_poll</span><br>                                            <span class="hljs-comment">//       遍历 socket等待队列，拿到上面添加的 pwq-&gt;wait，将其传入 ep_poll_callback</span><br>                                            ep_poll_callback(<span class="hljs-type">wait_queue_t</span> *wait, <span class="hljs-type">unsigned</span> mode, <span class="hljs-type">int</span> sync, <span class="hljs-type">void</span> *key) <span class="hljs-comment">// wait是socket等待队列</span><br>                                                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epitem</span> *<span class="hljs-title">epi</span> =</span> ep_item_from_wait(wait); <span class="hljs-comment">// 从 wait 找到 epi</span><br>                                                    container_of(p, <span class="hljs-keyword">struct</span> eppoll_entry, wait)-&gt;base; <span class="hljs-comment">// base指向epi</span><br>                                                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">eventpoll</span> *<span class="hljs-title">ep</span> =</span> epi-&gt;ep; <span class="hljs-comment">// 从epi拿到ep</span><br>                                                <br>                                                <span class="hljs-comment">// NOTE：key是file主动report状态变化时传来的状态位，如果不符合用户的兴趣，过滤，避免唤醒用户</span><br>                                                <span class="hljs-keyword">if</span> (key &amp;&amp; !((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) key &amp; epi-&gt;event.events))<br>		                                            <span class="hljs-keyword">goto</span> out_unlock;<br><br>                                                <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ep_poll_callback作用1：添加ready list</span><br>                                                <span class="hljs-keyword">if</span> (!ep_is_linked(&amp;epi-&gt;rdllink))<br>                                                    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 重要的是epi中记录了事件源（也就是此事件属于哪个FD），加入ep的ready list</span><br>                                                    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 我理解epi-&gt;rdllink 实际上并不代表链表，只是代表单个节点，而ep-&gt;rdllist才真正是链表</span><br>                                                    list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);<br>                                                        __list_add(new, head-&gt;prev, head);<br>                                                            <span class="hljs-comment">// new添加到head-&gt;prev与head中间，也就是添加到尾部</span><br>                                                <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ep_poll_callback作用2：唤醒阻塞在epoll_wait的元素</span><br>                                                <span class="hljs-comment">// NOTE：如果没有进程阻塞在epoll_wait上，这里不会调用，但不影响上面将epi添加到ready list</span><br>                                                <span class="hljs-keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq)) <span class="hljs-comment">// wq中的list是否empty</span><br>                                                    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 唤醒所有阻塞在 epoll_wait 的</span><br>                                                    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ep-&gt;wq 是 wait_queue_head_t 类型，其 task_list 字段中存的是 wait_queue_t 类型</span><br>                                                    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> select中 wake_up 系列是留给监听的file调用的，这里的context是 sk_data_ready -&gt; wake_up_interruptible_sync_poll 好吧也是监听的file</span><br><br>                                                    <span class="hljs-comment">// 相比于select是拿到select调用时创建的table，利用其中的current调用default_wake_function</span><br>                                                    <span class="hljs-comment">// 这里是拿到了ep-&gt;wq，对其中的元素调用func，</span><br>                                                    <span class="hljs-comment">// 相当于select只有一层queue，在sk_data_ready对应的socket</span><br>                                                    <span class="hljs-comment">// 而ep除了socket有queue以外，epfd自身也维护了ep-&gt;wq</span><br>                                                    <span class="hljs-comment">// 在epoll调用时，会申请一个 wait_queue_t 加入这第二层的 ep-&gt;wq</span><br>                                                    <span class="hljs-comment">// NOTE：猜想原因是可能对这个epfd有多个线程调用了epoll_wait，而select则没有fd，也就不会有这种情况</span><br>                                                    wake_up_locked(&amp;ep-&gt;wq); <br>                                                        <span class="hljs-comment">// #define wake_up_locked(x)		__wake_up_locked((x), TASK_NORMAL)</span><br>                                                            __wake_up_locked(<span class="hljs-type">wait_queue_head_t</span> *q, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mode)<br>                                                                __wake_up_common(q, mode, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>                                                                    <span class="hljs-comment">// 这些遍历时的元素在epoll_wait时添加</span><br>                                                                    list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list)<br>                                                                        <span class="hljs-comment">// // curr类型 wait_queue_t</span><br>                                                                        <span class="hljs-comment">// NOTE：但是select的 pollwake 确实是调用了 try_to_wake_up 的</span><br>                                                                        curr-&gt;func(curr, mode, wake_flags, key)<br>                                                                            default_wake_function<br>                                                                                try_to_wake_up<br>                                                <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> epoll套epoll的情况</span><br>                                                <span class="hljs-keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))<br>                                                    pwake++;<br>                                                <span class="hljs-keyword">if</span> (pwake)<br>                                                    ep_poll_safewake(&amp;ep-&gt;poll_wait);<br>                                                    <span class="hljs-comment">// 本质是调用wake_up，唤醒所有等待我们的，也就是epfd被等待的情况，可以是select套epfd，也可以是epoll套epfd</span><br>                <span class="hljs-comment">// 根据socket队列是否为空等条件返回mask</span><br>                <span class="hljs-keyword">return</span> mask<br>    list_add_tail(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links); <span class="hljs-comment">// 不明</span><br>    ep_rbtree_insert(ep, epi); <span class="hljs-comment">// 将上面初始化的epi添加到红黑树</span><br>        <span class="hljs-comment">// TODO 有空学习下红黑树</span><br>    <span class="hljs-comment">/* If the file is already &quot;ready&quot; we drop it inside the ready list */</span><br>	<span class="hljs-keyword">if</span> ((revents &amp; event-&gt;events) &amp;&amp; !ep_is_linked(&amp;epi-&gt;rdllink))<br>        <span class="hljs-comment">// NOTE：如果已经ready，加入ready list，接着epoll_wait的时候就会再次poll了</span><br>        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);<br>        <span class="hljs-comment">/* Notify waiting tasks that events are available */</span><br>        <span class="hljs-comment">/* 如果进程正在睡眠等待，唤醒它去处理就绪事件 */</span><br>		<span class="hljs-keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))<br>			wake_up_locked(&amp;ep-&gt;wq);<br>		<span class="hljs-keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))<br>			pwake++;<br>    atomic_long_inc(&amp;ep-&gt;user-&gt;epoll_watches);<br><br>    <span class="hljs-keyword">if</span> (pwake)<br>		ep_poll_safewake(&amp;ep-&gt;poll_wait);<br>            ep_call_nested(&amp;poll_safewake_ncalls, EP_MAX_NESTS,<br>		       ep_poll_wakeup_proc, <span class="hljs-literal">NULL</span>, wq, (<span class="hljs-type">void</span> *) (<span class="hljs-type">long</span>) this_cpu);<br>                <span class="hljs-comment">// priv对应NULL，cookie对应wq: wait_queue_head_t</span><br>                ep_poll_wakeup_proc(<span class="hljs-type">void</span> *priv, <span class="hljs-type">void</span> *cookie, <span class="hljs-type">int</span> call_nests)<br>                    ep_wake_up_nested((<span class="hljs-type">wait_queue_head_t</span> *) cookie, POLLIN, <span class="hljs-number">1</span> + call_nests);<br>                    <span class="hljs-comment">// #define wake_up_poll(x, m)				\</span><br><span class="hljs-comment">                    // __wake_up(x, TASK_NORMAL, 1, (void *) (m))</span><br>                        __wake_up<br>                            __wake_up_common(q, mode, nr_exclusive, <span class="hljs-number">0</span>, key); <span class="hljs-comment">// kernel/sched.c</span><br>                                list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list)<br>                                    curr-&gt;func(curr, mode, wake_flags, key)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * __wake_up - wake up threads blocked on a waitqueue.</span><br><span class="hljs-comment"> * @q: the waitqueue</span><br><span class="hljs-comment"> * @mode: which threads</span><br><span class="hljs-comment"> * @nr_exclusive: how many wake-one or wake-many threads to wake up</span><br><span class="hljs-comment"> * @key: is directly passed to the wakeup function</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> __wake_up(<span class="hljs-type">wait_queue_head_t</span> *q, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mode,<br>			<span class="hljs-type">int</span> nr_exclusive, <span class="hljs-type">void</span> *key)<br></code></pre></td></tr></table></figure>

<h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE4(epoll_wait, <span class="hljs-type">int</span>, epfd, <span class="hljs-keyword">struct</span> epoll_event __user *, events,<br>		<span class="hljs-type">int</span>, maxevents, <span class="hljs-type">int</span>, timeout)<br>    <span class="hljs-comment">/* Verify that the area passed by the user is writeable */</span><br>    access_ok(VERIFY_WRITE, events, maxevents * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> epoll_event))<br>    file = fget(epfd);<br>    <span class="hljs-keyword">if</span> (!is_file_epoll(file))<br>        <span class="hljs-comment">// ...</span><br>    error = ep_poll(ep, events, maxevents, timeout);<br>    <span class="hljs-keyword">return</span> error<br><br><span class="hljs-comment">// NOTE：尾部调用不再缩进</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> ep_poll(<span class="hljs-keyword">struct</span> eventpoll *ep, <span class="hljs-keyword">struct</span> epoll_event __user *events,<br>		   <span class="hljs-type">int</span> maxevents, <span class="hljs-type">long</span> timeout)<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, eavail, timed_out = <span class="hljs-number">0</span>; <span class="hljs-comment">// 注意这里有两个timeout，我们关注的无超时情况下 timed_out == 0</span><br>    <span class="hljs-type">wait_queue_t</span> wait;<br>    <span class="hljs-keyword">if</span> (timeout &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// ... 不看超时的部分</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timeout == <span class="hljs-number">0</span>) <span class="hljs-comment">// 非阻塞</span><br>        <span class="hljs-comment">// ... 只看阻塞的</span><br>fetch_events:<br>    <span class="hljs-keyword">if</span> (!ep_events_available(ep)) <span class="hljs-comment">// 根据rdllist是否为空判断</span><br>        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 注入current</span><br>        init_waitqueue_entry(&amp;wait, current);<br>            <span class="hljs-comment">// q 就是 wait</span><br>            q-&gt;flags = <span class="hljs-number">0</span>;<br>            q-&gt;private = p; <span class="hljs-comment">// 将current写到p</span><br>            q-&gt;func = default_wake_function;<br>		__add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait); <span class="hljs-comment">// 将 wait_queue_t 加入 ep-&gt;wq (wait_queue_head_t 类型)</span><br>            wait-&gt;flags |= WQ_FLAG_EXCLUSIVE;<br>            __add_wait_queue(q, wait); <span class="hljs-comment">// __add_wait_queue(wait_queue_head_t *head, wait_queue_t *new)</span><br>                list_add(&amp;new-&gt;task_list, &amp;head-&gt;task_list); <span class="hljs-comment">// list_add(struct list_head *new, struct list_head *head)</span><br>        <span class="hljs-keyword">for</span> (;;)<br>            set_current_state(TASK_INTERRUPTIBLE);<br>            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 通过检查队列是否为空判断，而非通过poll判断，这使得ET不会基于fd的poll返回值，但是这样不就永远走不到后面的poll了吗？</span><br>            <span class="hljs-comment">// NOTE：错误的，sk_data_ready -&gt; wake_up_interruptible_sync_poll 路径仍然会从socket wait_queue中拿到之前注册的epi，将</span><br>			<span class="hljs-keyword">if</span> (ep_events_available(ep) || timed_out)<br>				<span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (signal_pending(current))<br>				res = -EINTR;<br>				<span class="hljs-keyword">break</span>;<br>			<span class="hljs-comment">// ref: https://hackmd.io/@hankluo6/2021q3_quiz4</span><br>            <span class="hljs-comment">// 當目前沒有事件要處理時，schedule_hrtimeout_range 會主動讓出 CPU 給其他 process，而當 schedule_hrtimeout_range 回傳時表示被喚醒或 timeout</span><br>            <span class="hljs-comment">// ===</span><br>            <span class="hljs-comment">// 函数文档中有说将task state设置为 TASK_INTERRUPTIBLE 的话也可以因为 interrupt 醒来</span><br>            schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS) <span class="hljs-comment">// Returns 0 when the timer has expired otherwise -EINTR 想看timeout分支的话可以参考下</span><br>                schedule_hrtimeout_range_clock<br>                    <span class="hljs-title function_">if</span> <span class="hljs-params">(!expires)</span><br>                        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 阻塞点</span><br>                        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 所以看起来epoll是依赖interrupt，否则就一直主动放弃CPU？</span><br>                        <span class="hljs-title function_">schedule</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 这是无超时情况的分支，expires就是传进来的to，是NULL</span><br>                        __set_current_state(TASK_RUNNING);<br>		                <span class="hljs-keyword">return</span> -EINTR;<br>        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait); <span class="hljs-comment">// 取消等待</span><br>        set_current_state(TASK_RUNNING);<br>    eavail = ep_events_available(ep);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">	 * Try to transfer events to user space. In case we get 0 events and</span><br><span class="hljs-comment">	 * there&#x27;s still timeout left over, we go trying again in search of</span><br><span class="hljs-comment">	 * more luck.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;<br>	    !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; !timed_out)<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ep_send_events_data</span> <span class="hljs-title">esed</span>;</span><br>            esed.maxevents = maxevents;<br>	        esed.events = events; <span class="hljs-comment">// 用户传来的</span><br>            <span class="hljs-keyword">return</span> ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed);<br>                LIST_HEAD(txlist);<br>                list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist); <span class="hljs-comment">// 合并rdllist与txlist，重置rdllist为空</span><br>                error = (*sproc)(ep, &amp;txlist, priv)<br>                    ep_send_events_proc(ep, txlist, esed) <span class="hljs-comment">// (ep, head, priv)</span><br>                        <span class="hljs-keyword">struct</span> ep_send_events_data *esed = priv;<br>                        <span class="hljs-keyword">for</span> (eventcnt = <span class="hljs-number">0</span>, uevent = esed-&gt;events; !list_empty(head) &amp;&amp; eventcnt &lt; esed-&gt;maxevents;)<br>                            epi = list_first_entry(head, <span class="hljs-keyword">struct</span> epitem, rdllink); <span class="hljs-comment">// 从txlist取item，原本来自于ep的rdllist</span><br>                            <span class="hljs-comment">// fd在insert时申请epi</span><br>                            list_del_init(&amp;epi-&gt;rdllink); <span class="hljs-comment">// 从队头移除</span><br>                            <span class="hljs-comment">// 位运算，如果和用户关心的事件有重叠</span><br>                            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 重要，调用poll检查其是否有我们关心的状态，注意做了与运算</span><br>                            revents = epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, <span class="hljs-literal">NULL</span>) &amp;<br>                                epi-&gt;event.events;<br>                            <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> EPOLLIN 和 POLLIN 是一样的，事实上 EPOLL 的一系列宏（也许除了 EPOLLET）都和select系列是一样的</span><br>                            <span class="hljs-comment">// ref: https://stackoverflow.com/questions/30685515/are-poll-and-epoll-event-flags-compatible</span><br>                            <span class="hljs-keyword">if</span> (revents)<br>                                <span class="hljs-comment">// uevent指向用户传来的 events 数组item</span><br>                                __put_user(revents, &amp;uevent-&gt;events) <span class="hljs-comment">// 拷贝回用户空间，revents指出有哪些事件</span><br>                                __put_user(epi-&gt;event.data, &amp;uevent-&gt;data) <span class="hljs-comment">// 是哪个fd触发的</span><br>                                eventcnt++;<br>			                    uevent++; <span class="hljs-comment">// 指向下一个位置</span><br><br>                                <span class="hljs-comment">// 如果非ET（也就是LT），将epi放回ep的ready list，下次wait时如果没有数据就不会通过 if (revents) 判断，也就不会再在ready list中出现了</span><br>                                <span class="hljs-comment">// 而ET的情况需要一次读完，否则只有下次 sk_data_ready 才能再次知道这个fd可读</span><br>                                <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 下面这么一小段代码实现了LT和ET的差别</span><br>                                <span class="hljs-keyword">if</span> (!(epi-&gt;event.events &amp; EPOLLET))  <br>                                    list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);<br>                    <span class="hljs-keyword">return</span> eventcnt;<br>                <span class="hljs-keyword">return</span> error;<br>		<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 有可能LT不清空ready list，再次进入这里但没有poll到用户关心的事件，这种情况下ready list被清空后应该重新阻塞</span><br>        <span class="hljs-keyword">goto</span> fetch_events;<br>    <span class="hljs-keyword">return</span> res;<br></code></pre></td></tr></table></figure>

<h3 id="总结（epoll）"><a href="#总结（epoll）" class="headerlink" title="总结（epoll）"></a>总结（epoll）</h3><p>TODO 看一下[2]的源码说明</p>
<p>与select类似的是都用到了linux的等待队列机制，有代码复用，所以读起来轻松不少</p>
<h4 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h4><p>TODO pollwake 的深入分析请见 <a target="_blank" rel="noopener" href="http://gityuan.com/2018/12/02/linux-wait-queue/">http://gityuan.com/2018/12/02/linux-wait-queue/</a></p>
<p>context为poll时：向socket的等待队列添加包装后的函数指针<br>init_waitqueue_func_entry(&amp;entry-&gt;wait, pollwake);<br>init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</p>
<p>context为 sk_data_ready -&gt; wake_up_interruptible_sync_poll -&gt; __wake_up_sync_key -&gt;__wake_up_common -&gt; list_for_each_entry_safe -&gt; curr-&gt;func<br>遍历file的等待队列，调用上面包装后的函数指针，curr-&gt;func(curr …)，注意等待队列中的元素curr自身也被传入了，<strong>这个curr中是包含了select&#x2F;epoll_wait调用时记录的当前进程的，因此可以知道要唤醒谁</strong>（epoll的不完全正确，但可以这么理解）</p>
<h5 id="epoll-ctl分析"><a href="#epoll-ctl分析" class="headerlink" title="epoll_ctl分析"></a>epoll_ctl分析</h5><p>从 EPOLL_CTL_ADD 开始分析：</p>
<p>epi对应一个加入的fd，会加入红黑树（与ready list），其中包含一个qproc，随后调用file的poll时，file的poll应当会调用poll_wait，并将poll_table传入（通过container_of可以找到包裹poll_table的epi），qproc调用时，会申请一个 eppoll_entry 对象，它的主要作用是包装callback ep_poll_callback，加入file的等待队列（ctl_add时加入，ctl_del时删除）。file在状态变化时应主动调用callback，这个callback做三件事：</p>
<ol>
<li>过滤用户不关心的状态变化，避免走到下面导致唤醒</li>
<li>将epi添加到readylist（如果没有已经添加的话）</li>
<li>如果ep的等待队列不为空（有进程阻塞在当前epfd的epoll_wait），遍历它们 （wait_queue_t），在其中能找到阻塞进程的task_struct，唤醒它们</li>
</ol>
<h5 id="epoll-wait分析"><a href="#epoll-wait分析" class="headerlink" title="epoll_wait分析"></a>epoll_wait分析</h5><ol>
<li>如果ep的ready list为空，那么自己将要阻塞，申请一个wait_queue_t对象，填入当前进程的task_struct，添加到ep的等待队列，不断调用schedule让出CPU，每次被唤醒（或被调度）时检查ready list是否为空。</li>
<li>ready list不为空的状态下，遍历ready list调用poll，过滤取得的mask（与运算），将事件消息（哪个fd触发、是什么事件类型）拷贝回用户态传入的buffer。如果是LT，符合兴趣的file会放回ready list，下次epoll_wait时会略过步骤1，重新poll，因此实现了LT。ET则不会放回ready list，需要file主动汇报状态触发install的callback才能重新使ready list非空，因此实现了ET。</li>
</ol>
<h4 id="与select的比较"><a href="#与select的比较" class="headerlink" title="与select的比较"></a>与select的比较</h4><ul>
<li>select每次调用全量拷贝了用户感兴趣的fd到内核状态，而epoll是增量的</li>
<li>select使用bitmap维护感兴趣的fd，O1插入删除、On遍历（这里不讨论用户态与内核态的拷贝），而epoll平衡了插入删除与遍历，均为红黑树复杂度</li>
<li>select每次调用与唤醒时需要On poll一遍，epoll在epoll_ctl需要poll一次，后续epoll_wait阻塞前不poll，唤醒后poll一次，注意epoll只poll有事件的fd</li>
</ul>
<p>配一张图便于理解[6]<br><img src="https://pic2.zhimg.com/80/v2-5ce040484bbe61df5b484730c4cf56cd_1440w.jpg" srcset="/img/loading.gif" lazyload></p>
<h4 id="ET与LT的区别"><a href="#ET与LT的区别" class="headerlink" title="ET与LT的区别"></a>ET与LT的区别</h4><p>LT不会清理wait_list，下次调用epoll_wait时会重新对file进行poll，若无关心的事件才会移出队列，而wait_list不会保留在队列中，意味着这是监听的fd下次主动汇报状态之前（以socket为例，等价于有新数据）仅有的一次通知机会。或者先CTL DEL后ADD也可以重新触发poll</p>
<h4 id="为什么有人说ET更快"><a href="#为什么有人说ET更快" class="headerlink" title="为什么有人说ET更快"></a>为什么有人说ET更快</h4><p>我的理解，LT每次调用epoll_wait如果使用阻塞fd只能读一次来避免阻塞，但如果使用非阻塞fd倒是和ET没什么区别</p>
<p>ref[5]</p>
<blockquote>
<p>在eventloop类型(包括各类fiber&#x2F;coroutine)的程序中, 处理逻辑和epoll_wait都在一个线程, ET相比LT没有太大的差别. 反而由于LT醒的更频繁, 可能时效性更好些. 在老式的多线程RPC实现中, 消息的读取分割和epoll_wait在同一个线程中运行, 类似上面的原因, ET和LT的区别不大.但在更高并发的RPC实现中, 为了对大消息的反序列化也可以并行, 消息的读取和分割可能运行和epoll_wait不同的线程中, 这时ET是必须的, 否则在读完数据前, epoll_wait会不停地无谓醒来.</p>
</blockquote>
<h4 id="不当的使用可能造成饥饿"><a href="#不当的使用可能造成饥饿" class="headerlink" title="不当的使用可能造成饥饿"></a>不当的使用可能造成饥饿</h4><p>Question：我看网上有人说ET需要配合robin list，这个和ET&#x2F;LT没什么关系吧</p>
<p>ref[1] 简单来说就是对epoll_wait返回的fd不要一直读，如果这个fd有大量数据，就会导致其他fd的饥饿，正确做法是搞一个类似round_robin的机制去循环读所有fd</p>
<h4 id="惊群问题"><a href="#惊群问题" class="headerlink" title="惊群问题"></a>惊群问题</h4><p>如果多线程阻塞在同一个fd上是会有惊群问题的，一种想法是，每个线程对应单独的一个epfd，其中一个线程专门负责accept，accept后的连接epoll_ctl到其他线程的epfd，可以避免此问题</p>
<p>[4]中提到的另一种做法是每个线程对应一个epfd，都监听listenfd，根据上文的源码分析，listenfd事件到来后是会发生惊群的</p>
<p>TODO 解决方案 [4]中有提到，先不看了</p>
<p>Question: accept是线程安全的吗？<br>ref: Is accept() thread-safe? <a target="_blank" rel="noopener" href="https://stackoverflow.com/a/5124450/8454039">https://stackoverflow.com/a/5124450/8454039</a><br>省流：是的</p>
<h4 id="为什么使用红黑树？"><a href="#为什么使用红黑树？" class="headerlink" title="为什么使用红黑树？"></a>为什么使用红黑树？</h4><ol>
<li>需要判断fd是否已经正在监听，需要较高的查询效率，select以空间换时间，</li>
<li>若fd不存在则需要插入，也需要考虑插入复杂度</li>
</ol>
<p>红黑树兼顾了插入、查询效率与树的旋转次数<br>TODO 我记得旋转次数是它和AVL的区别，但是知乎上也有人放数据显示差不多…… AVL由于最平衡查询快，红黑树旋转少则插入删除快</p>
<h4 id="如果读完一个ET返回的socket，但在调用epoll-wait前，来了新的数据，且调用epoll-wait后不再来新数据（假设必须要我们根据这条数据回复后对方才会发新数据），是否会有liveness问题？"><a href="#如果读完一个ET返回的socket，但在调用epoll-wait前，来了新的数据，且调用epoll-wait后不再来新数据（假设必须要我们根据这条数据回复后对方才会发新数据），是否会有liveness问题？" class="headerlink" title="如果读完一个ET返回的socket，但在调用epoll_wait前，来了新的数据，且调用epoll_wait后不再来新数据（假设必须要我们根据这条数据回复后对方才会发新数据），是否会有liveness问题？"></a>如果读完一个ET返回的socket，但在调用epoll_wait前，来了新的数据，且调用epoll_wait后不再来新数据（假设必须要我们根据这条数据回复后对方才会发新数据），是否会有liveness问题？</h4><p>不会的，没有人在epoll_wait只是影响socket回调不会调用wakeup通知阻塞方，而ctl poll时添加的epi还是在的，并不影响将epi添加到ready list的过程。因此即使中间有较短的时间不阻塞在epoll_wait但是来了数据，调用epoll_wait的时候由于ready list非空，还是会走到poll，拷贝回用户空间，正常返回的，并不会hang住</p>
<h4 id="为什么在边缘触发的epoll函数中要使用非阻塞fd？"><a href="#为什么在边缘触发的epoll函数中要使用非阻塞fd？" class="headerlink" title="为什么在边缘触发的epoll函数中要使用非阻塞fd？"></a>为什么在边缘触发的epoll函数中要使用非阻塞fd？</h4><p>对于connfd<br>LT的话是每次epoll_wait返回后只读一次，无论使用阻塞非阻塞都是一样的，因为只读一次，一定不阻塞<br>ET的话是每次epoll_wait返回后为了读完数据，需要循环读，阻塞fd会导致卡住，就算单独开了个线程去读，卡住也是不好的状态；而非阻塞connfd根据EAGAIN返回码即可判断是否读完</p>
<p>对于listenfd<br>nginx用的是LT（其他read write用的是ET），socketfd也是可选block&#x2F;nonblock的[8]，所以感觉ET其实也行？</p>
<p>LT与ET的epoll例子<br><a target="_blank" rel="noopener" href="https://gist.github.com/liumuqi/04dc92629e322a4613a4610afe786818">https://gist.github.com/liumuqi/04dc92629e322a4613a4610afe786818</a></p>
<p>TODO 关于非阻塞的想法，推荐扩展阅读<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/nacUx_qQr93_y-CsVxkejA">高性能网络通信库中为何要将侦听 socket 设置成非阻塞的？</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU2MTkwMTE4Nw==&mid=2247487973&idx=2&sn=140004b0dfde45745091ab5c6522dcba&scene=21#wechat_redirect">one thread one loop 思想</a></p>
<h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>其实还没来得及读<br><a target="_blank" rel="noopener" href="https://wenfh2020.com/2021/11/21/question-nginx-epoll-et/">[知乎回答] Nginx为啥使用ET模式Epoll？</a></p>
<h3 id="参考文章（epoll）"><a href="#参考文章（epoll）" class="headerlink" title="参考文章（epoll）"></a>参考文章（epoll）</h3><ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/92617116">epoll边缘触发模式</a></li>
<li><a target="_blank" rel="noopener" href="https://wenfh2020.com/2020/04/23/epoll-code/#88-ep_send_events_proc">[内核源码] epoll 实现原理</a></li>
<li><a target="_blank" rel="noopener" href="https://wenfh2020.com/2020/06/11/epoll-lt-et/">[内核源码] epoll lt &#x2F; et 模式区别</a></li>
<li><a target="_blank" rel="noopener" href="https://wenfh2020.com/2021/11/22/question-thundering-herd/">[知乎回答] socket的任意event都会导致epoll_wait的惊群效应吗？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20502870">epoll的边沿触发模式(ET)真的比水平触发模式(LT)快吗？(当然LT模式也使用非阻塞IO，重点是要求ET模式下的代码不能造成饥饿)</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/64138532">如果这篇文章说不清epoll的本质，那就过来掐死我吧！ （2）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xcywt/p/8146094.html">epoll的使用实例</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12861956/is-it-possible-and-safe-to-make-an-accepting-socket-non-blocking">Is it possible (and safe) to make an accepting socket non-blocking?</a></li>
</ol>
<h2 id="Reactor与Proactor"><a href="#Reactor与Proactor" class="headerlink" title="Reactor与Proactor"></a>Reactor与Proactor</h2><p>篇幅较短，就不新写一篇了</p>
<h3 id="参考文章（Reactor与Proactor）"><a href="#参考文章（Reactor与Proactor）" class="headerlink" title="参考文章（Reactor与Proactor）"></a>参考文章（Reactor与Proactor）</h3><p>单Reactor单线程，同一个线程既负责阻塞在epoll_wait上，也负责事件到来后的处理</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    epoll_wait()<br>    <span class="hljs-keyword">for</span> fd <span class="hljs-keyword">in</span> fds: <span class="hljs-comment"># fds that has event</span><br>        <span class="hljs-keyword">if</span> fd == listenfd:<br>            acceptfd = accept(listenfd)<br>            epoll_ctl(epfd, ADD, acceptfd)<br>        <span class="hljs-keyword">else</span>:<br>            data = read(fd)<br>            handlerDict[fd].handleFunc(data)<br></code></pre></td></tr></table></figure>

<p>单Reactor多线程：Reactor线程只处理连接事件和读写事件，业务处理交给线程池处理[2]</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">while</span> true:<br>    epoll_wait()<br>    <span class="hljs-keyword">for</span> fd <span class="hljs-keyword">in</span> fds: <span class="hljs-comment"># fds that has event</span><br>        <span class="hljs-keyword">if</span> fd == listenfd:<br>            acceptfd = accept(listenfd)<br>            epoll_ctl(epfd, ADD, acceptfd)<br>        <span class="hljs-keyword">else</span>:<br>            data = read(fd)<br>            threadPool.submit(Task(fd, data))<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span>:<br><span class="hljs-meta">    @Override</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">Runnable r</span>):<br>        result = handlerDict[self.fd].handleFunc(self.data)<br>        write(fd, result)<br></code></pre></td></tr></table></figure>

<p>主从Reactor多线程：认为accept连接比处理数据ready（准备好被读）要重要</p>
<ol>
<li>谁能告诉我proactor和reactor分别怎么回事？ - bin的技术小屋的回答 - 知乎<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/486675100/answer/2535826912">https://www.zhihu.com/question/486675100/answer/2535826912</a></li>
<li>Reactor线程模型 - 每天晒白牙的文章 - 知乎<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/69341619">https://zhuanlan.zhihu.com/p/69341619</a></li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%8A%80%E6%9C%AF/" class="category-chain-item">技术</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">#计算机网络</a>
      
        <a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">#源码阅读</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>select poll epoll 源码阅读</div>
      <div>https://vicety.github.io/2022/08/18/select-poll-epoll/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Beitragsautor</div>
          <div>vicety</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Veröffentlicht am</div>
          <div>2022年8月18日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>Urheberrechtshinweis</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/15/sriov-device-plugin%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" title="Kubernetes Device Plugin机制 —— 以SR-IOV Device Plugin为例">
                        <span class="hidden-mobile">Kubernetes Device Plugin机制 —— 以SR-IOV Device Plugin为例</span>
                        <span class="visible-mobile">Nächster</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"p7Skzx1UifgNosmr5ms2nILv-gzGzoHsz","appKey":"W73NSV1s3dRPtfceJDBsX5uP","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Suchen</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Stichwort</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog funktioniert am besten mit aktiviertem JavaScript</div>
  </noscript>
</body>
</html>
